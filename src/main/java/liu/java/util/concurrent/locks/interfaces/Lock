-----------------------------------------Lock-----------------------------------------------------------------------------------------------------------------------------		
Lock：锁 【Since:1.5】
	Lock实现提供了比使用同步方法和语句可以获得的更广泛的锁定操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的Condition对象。
	锁是用于控制多个线程对共享资源的访问的工具。通常，锁提供对共享资源的独占访问：一次只有一个线程可以获取锁，对共享资源的所有访问都要求首先获取锁。但是，某些锁可能允许并发访问共享资源，例如ReadWriteLock的读锁。
	使用synchronized方法或语句可以访问与每个对象关联的隐式监视器锁，但会强制以块结构的方式进行所有锁的获取和释放：当获取多个锁时，必须以相反的顺序释放它们，并且所有锁都必须在它们所处的相同词汇范围中释放、获取。
	虽然synchronized方法和语句的作用域机制使使用监视器锁进行编程变得更容易，并且有助于避免涉及锁的许多常见编程错误，但有时需要以更灵活的方式使用锁。例如，一些遍历并发访问数据结构的算法需要使用“移交”（hand-over-hand）或“链锁定”（chain locking）：先获取节点A的锁，然后获取节点B，然后释放A和获取C，然后释放B和获取D等。Lock接口的实现允许在不同范围内获取和释放锁，并允许以任意顺序获取和释放多个锁，从而允许使用此类技术。
	随着灵活性的提高，还需要承担额外的责任。块结构锁的缺失消除了synchronized方法和语句发生的锁的原子释放。在大多数情况下，应使用以下习惯：
		 Lock l = ...;
		 l.lock();
		 try {
		   // access the resource protected by this lock
		 } finally {
		   l.unlock();
		 }		
	当锁定和解锁发生在不同的作用域中时，必须注意确保在持有锁时执行的所有代码都受到try finally或try catch的保护，以确保在必要时释放锁。
	Lock实现通过提供获取锁的非阻塞尝试（tryLock()），获取可以中断的锁的尝试（lockInterruptibly()，以及获取可以超时的锁的尝试（tryLock(long, TimeUnit)），提供了使用synchronized方法和语句的额外功能。
	Lock类还可以提供与隐式监视器锁非常不同的行为和语义，例如保证排序、不可重入使用或死锁检测。如果一个实现提供了这种专门的语义，那么该实现必须记录这些语义。
	请注意，Lock实例只是普通对象，它们本身可以在synchronized语句中用作目标。获取Lock实例的监视器锁与调用该实例的任何lock()方法没有指定的关系。为了避免混淆，建议不要以这种方式使用Lock实例，除非在它们自己的实现中。
	除非另有说明，否则为任何参数传递空值将导致引发NullPointerException异常。
	
	Memory Synchronization（内存同步）：
	所有Lock实现必须像内置的监视器锁所提供的相同的内存同步语义，如Java语言规范（17.4内存模型）中所描述的：
		● 成功的锁定（lock）操作与成功的Lock操作具有相同的内存同步效果。
		● 成功的解锁（unlock）操作与成功的Unlock操作具有相同的内存同步效果。 
	不成功的锁定和解锁操作以及可重入的锁定/解锁操作不需要任何内存同步效果。
	
	Implementation Considerations(实施注意事项)：
	锁获取的三种形式（中断、不可中断和定时）可能在性能特征、顺序保证或其他实现质量方面有所不同。此外，在给定的Lock类中，中断正在进行的锁获取的能力可能不可用。因此，实现不需要为所有三种形式的锁获取定义完全相同的保证或语义，也不需要支持正在进行的锁获取的中断。需要一个实现来清晰地记录每个锁定方法提供的语义和保证。在支持锁获取中断的范围内，它还必须遵守此接口中定义的中断语义：完全或仅在方法条目上。
	由于中断通常意味着取消，并且对中断的检查通常不频繁，因此实现可以优先响应中断而不是正常方法返回。这是真的，即使可以证明中断发生在另一个操作可能已解除线程阻塞之后。实现应该记录这种行为。
	
	
	
	接口定义	：public interface Lock
	接口实现类	：ReentrantLock, ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	lock():void 
		获取锁。
		如果锁不可用，则出于线程调度的目的，当前线程将被禁用，并处于休眠状态，直到获取锁为止。
		实施注意事项：
		Lock实现可以检测到对锁的错误使用，例如会导致死锁的调用，并且在这种情况下可能抛出（未选中）异常。环境和异常类型必须由该Lock实现进行记录。
	lockInterruptibly():void  throws InterruptedException
		获取锁，除非当前线程被中断。
		获取可用的锁并立即返回。
		如果锁不可用，则出于线程调度目的，当前线程将被禁用，并处于休眠状态，直到发生以下两种情况之一：
			● 该锁由当前线程获取；或
			● 其他线程中断当前线程，并且支持中断锁获取。
		如果当前线程：
			● 在进入此方法时是否设置了中断状态；或
			● 获取锁时中断，支持锁获取中断，
		然后抛出InterruptedException，并清除当前线程的中断状态。
		实施注意事项：
		在某些实现中，中断锁获取的能力可能是不可能的，如果可能，这可能是一个昂贵的操作。程序员应该知道情况可能是这样的。在这种情况下，实现应该记录下来。
		实现可以帮助响应一个中断，而不是正常的方法返回。
		Lock实现可以检测到对锁的错误使用，例如会导致死锁的调用，并且在这种情况下可能抛出（未选中）异常。环境和异常类型必须由该Lock实现进行记录。
		【Throws】：
			InterruptedException 如果当前线程在获取锁时中断（并且支持锁获取中断）。
	newCondition():Condition 
		返回绑定到此Lock实例的新Condition实例。
		在等待条件之前，锁必须由当前线程持有。对Condition.await()的调用将在等待前按原子释放锁，并在等待返回前重新获取锁。
		实施注意事项：
		Condition实例的确切操作取决于Lock的实现，并且必须由该实现进行记录。
		返回此Lock实例的新Condition实例。
		【Throws】：
			UnsupportedOperationException 如果此Lock实现不支持条件。
	tryLock():boolean 
		仅当锁在调用时是空闲的时获取锁。
		如果该锁可用，则获取该锁，并立即返回值true。如果锁不可用，则此方法将立即返回值false。
		这种方法的一个典型用法是：
			 Lock lock = ...;
			 if (lock.tryLock()) {
			   try {
			     // manipulate protected state
			   } finally {
			     lock.unlock();
			   }
			 } else {
			   // perform alternative actions
			 }		
		此用法确保在获取锁时将其解锁，并且在未获取锁时不会尝试解锁。
		如果获取了锁，则返回true，否则返回false。
	tryLock(long time, TimeUnit unit):boolean  throws InterruptedException
		time - 等待锁的最长时间
		unit - time参数时间单位
		如果在给定的等待时间内该锁是空闲的，并且当前线程未被中断，则获取该锁。	
		如果锁可用，此方法将立即返回值为true的值。如果锁不可用，则出于线程调度目的，当前线程将被禁用，并处于休眠状态，直到发生以下三种情况之一：
			● 该锁由当前线程获取；或
			● 其他线程中断当前线程，并且支持中断锁获取；或
			● 指定的等待时间已过
		如果获取了锁，则返回值true。
		如果当前线程：
			● 在进入此方法时是否设置了中断状态；或
			● 获取锁时中断，支持锁获取中断，
		然后抛出InterruptedException异常，并清除当前线程的中断状态。
		如果指定的等待时间已过，则返回值false。如果时间小于或等于零，该方法将根本不等待。
		实施注意事项：
		在某些实现中，中断锁获取的能力是不可能的，如果可能，这可能是一个昂贵的操作。程序员应该知道情况可能是这样的。在这种情况下，实现应该记录下来。
		实现可以支持响应中断而不是正常方法返回，或者报告超时。
		锁实现可以检测到对锁的错误使用，例如会导致死锁的调用，并且在这种情况下可能抛出（未选中）异常。环境和异常类型必须由该锁实现进行记录。
		如果获取了锁，则返回值true。如果指定的等待时间已过，则返回值false。
		【Throws】：
			InterruptedException 如果当前线程在获取锁时中断（并且支持锁获取中断）。
	unlock():void 
		释放锁。
		实施注意事项：
		Lock实现通常会对线程释放锁（通常只有锁的持有者才能释放锁）施加限制，如果违反了限制，则可能引发（未选中）异常。任何限制和异常类型都必须由该锁实现进行记录。


























