-----------------------------------------ReadWriteLock-----------------------------------------------------------------------------------------------------------------------------		
ReadWriteLock：读写锁 【Since:1.5】
	ReadWriteLock维护一对关联锁，一个用于只读操作，一个用于写入。只要没有写入程序，多个读线程就可以同时持有读锁。写锁是独占的。
	所有ReadWriteLock实现都必须确保writeLock操作（在Lock接口中指定）的内存同步效果也与关联的readLock保持一致。也就是说，成功获取读锁的线程将看到在先前的写锁版本上所做的所有更新。
	读写锁允许访问共享数据的并发性级别高于互斥锁允许的级别。它利用这样一个事实：虽然一次只有一个线程（编写器线程）可以修改共享数据，但在许多情况下，任何数量的线程都可以同时读取数据（从此读取线程）。理论上，读写锁允许的并发性的增加将导致与互斥锁相比的性能改进。实际上，这种并发性的增加只能在多处理器上完全实现，并且只有在共享数据的访问模式合适的情况下才能实现。
	读写锁是否会在使用互斥锁时提高性能取决于与被修改的数据相比，数据被读取的频率、读写操作的持续时间以及对数据的争用————也就是说，将尝试同时读取或写入数据的线程数。例如，最初使用数据填充的集合，之后不经常修改，而经常搜索的集合（例如某种目录）是使用读写锁的理想候选。但是，如果更新变得频繁，那么数据的大部分时间都是独占锁定的，并且几乎没有并发性的增加（如果有的话）。此外，如果读操作太短，读写锁实现的开销（本质上比互斥锁更复杂）可能会支配执行成本，特别是当许多读写锁实现仍然通过一小段代码序列化所有线程时。最终，只有分析和测量才能确定读写锁的使用是否适合您的应用程序。
	尽管读写锁的基本操作是直接进行的，但实现必须做出许多策略决策，这可能会影响给定应用程序中读写锁的有效性。这些策略的例子包括：
		● 当读取器和写入器正在等待时，在写入器释放写锁时，确定是授予读锁还是写锁。倾向于写入器是常见的，因为预计写入时间短且不频繁。倾向于读取器不太常见，因为读取器如预期那样时间长且频繁，那么它可能会导致写入的长时间延迟。“公平”或者“有序”策略的实现也许是可以的。
		● 确定在读取器处于活动状态且写入器正在等待时请求读锁的读取器是否被授予读锁。对倾向于读取器的可以无限期地延迟写入器，而对倾向于写入器的可以降低并发的可能性。
		● 确定锁是否可重入：具有写锁的线程能否重新获取它？	它能在保持写锁的同时获取读锁吗？	读锁本身是可重入的吗？
		● 写锁是否可以降级为读锁而不允许介入写入器？	读锁是否可以升级为写锁，而不是其他等待的读取器或写入器？
	在评估给定实现对应用程序的适用性时，应该考虑所有这些因素。
	
	
	
	接口定义	：public interface ReadWriteLock
	接口实现类	：ReentrantReadWriteLock
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	readLock():Lock 
		返回用于读取的锁。
	writeLock():Lock 
		返回用于写入的锁。























