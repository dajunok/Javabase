-------------------------------Formatter-----------------------------------------------------------------------------------------------------------------------
Formatter：格式字符串解释器。【since 1.5】
	用于printf-style格式字符串的解释器。此类支持数字、字符串和日期/时间数据的通用格式以及特定于区域设置的布局对齐和对齐输出。支持常见的Java类型，如字节、BigDecimal和日历。通过Formattable接口为任意用户类型提供有限的格式自定义。
	格式化程序不一定对多线程访问安全。线程安全是可选的，并且是此类中方法的用户的责任。
	Java语言的格式化打印受到C的PrTrF的极大启发。虽然格式字符串类似于C，但已经进行了一些定制以适应Java语言并利用其一些特性。此外，Java格式化比C更严格；例如，如果转换与标志不兼容，将抛出异常。在C语言中，不适用的标志将被静默忽略。因此，格式字符串的目的是使C程序员能够识别，但不一定与C中的字符串完全兼容。
	预期用途示例：
		StringBuilder sb = new StringBuilder();	  
		Formatter formatter = new Formatter(sb, Locale.US); //将所有输出发送到可附加对象sb
		formatter.format("%4$2s %3$2s %2$2s %1$2s", "a", "b", "c", "d") //显式参数索引可用于重新排序输出。
		// -> " d  c  b  a"
		
		//作为第一个参数的可选区域设置可用于获取特定于区域设置的数字格式。精度和宽度可用于圆整和对齐值。
		formatter.format(Locale.FRANCE, "e = %+10.4f", Math.E); // -> "e =    +2,7183"
		
		//“（”数字标志可用于用括号而不是负号格式化负数。组分隔符将自动插入。
		formatter.format("Amount gained or lost since last statement: $ %(,.2f",balanceDelta); // -> "Amount gained or lost since last statement: $ (6,217.58)"
	常见格式化请求的方便方法如下所示：
		//将格式化字符串写入System.out。
		System.out.format("Local time: %tT", Calendar.getInstance()); // -> "Local time: 13:34:18"
		
		//将格式化输出写入System.err。
		System.err.printf("Unable to open file '%1$s': %2$s",fileName, exception.getMessage());	// -> "Unable to open file 'food': No such file or directory"
		
	与C语言的sprintf(3)类似，可以使用静态方法String.format格式化字符串：：
		//格式化包含日期的字符串。
		import java.util.Calendar;
		import java.util.GregorianCalendar;
		import static java.util.Calendar.*;
		
		Calendar c = new GregorianCalendar(1995, MAY, 23);
		String s = String.format("Duke's Birthday: %1$tb %1$te, %1$tY", c);  // -> s == "Duke's Birthday: May 23, 1995"
	
	组织机构(Organization)	
		本规范分为两部分。第一部分概要介绍了基本的格式化概念。本节适用于希望快速入门并熟悉其他编程语言的格式化打印的用户。第二部分详细介绍了具体的实现细节。它适用于希望更精确地规范格式化行为的用户。
一、概要(Summary)	
	本节旨在简要概述格式化概念。有关操作的详细信息，请参阅详细信息部分。
	1、格式字符串语法：
		生成格式化输出的每个方法都需要一个格式字符串和参数列表。格式字符串是一个包含固定文本和一个或多个嵌入格式说明符的字符串。请考虑以下示例：
			Calendar c = ...;
			String s = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c);
		此格式字符串是格式方法的第一个参数。它包含三个格式说明符“%1$tm”、“%1$te”和“%1$ty”，指示应如何处理参数以及应将它们插入文本的位置。格式字符串的其余部分是固定文本，包括“Dukes Birthday：”和任何其他空格或标点。参数列表由格式字符串之后传递给方法的所有参数组成。在上面的示例中，参数列表的大小为1，由Calendar(日历)对象c组成。
		● 普通、字符和数字类型的格式说明符具有以下语法：
			%[argument_index$][flags][width][.precision]conversion
		  [argument_index$] 参数索引（可选）。是一个十进制整数，指示参数在参数列表中的位置。第一个参数由“1$”引用，第二个参数由“2$”引用，等等。
		  [flags] 			修改标记（可选）。是一组修改输出格式的字符。有效标志集取决于转换。
		  [width]			宽度（可选）。是一个正十进制整数，指示要写入输出的最小字符数。
		  [.precision]		字符数量限制可选）。（是一个非负的十进制整数，通常用于限制字符数。具体行为取决于转换。
		  conversion		转换格式（必须）。指示参数格式的字符。给定参数的有效转换集取决于参数的数据类型。
		● 用于表示日期和时间的类型的格式说明符具有以下语法：
			%[argument_index$][flags][width]conversion
		  [argument_index$]、[flags]和[width]这3个格式说明符与上面定义相同。
		  conversion		转换格式（必须）。是两个字符的序列。第一个字符是“t”或“T”。第二个字符表示要使用的格式。这些字符与GNU date和POSIX strftime(3c)定义的字符相似，但不完全相同。	
		● 与参数不对应的格式说明符具有以下语法：
			%[flags][width]conversion
		  [flags]和[width]两个格式说明符与上面定义相同。
		  conversion		转换格式（必须）。表示要插入到输出中的内容的字符。
	2、转换（Conversions）
		转换分为以下类别：
		<1>、General -可应用于任何参数类型
		<2>、Character - 可以应用于表示Unicode字符的基本类型：char, Character, byte, Byte, short, 和 Short。当Character.isValidCodePoint(int)返回true时，此转换也可以应用于int和integer类型。
		<3>、Numeric
			1、Integral - 可以应用于Java整数类型：byte, Byte, short, Short, int and Integer, long, Long, 和 BigInteger（但不是char或者Character）。
			2、Floating Point -可以应用于Java浮点类型： float, Float, double, Double, 和 BigDecimal。
		<4>、Date/Time - 可以应用于能够对日期或时间编码的Java类型：long, Long, Calendar, Date 和 TemporalAccessor。
		<5>、Percent - 生成文本“%”（'\u0025'）
		<6>、Line Separator -生成特定于平台的行分隔符 	
		下表总结了所有支持的转换。由大写字符（即 'B', 'H', 'S', 'C', 'X', 'E', 'G', 'A', and 'T'）表示的转换与相应小写转换字符的转换相同，但结果根据当前区域设置的规则转换为大写。结果等效于以下对String.toUpperCase()的调用  
			out.toUpperCase() 
		========================================================================================  
		转换字符（Conversion）	参数类别（Argument Category）		使用描述（Description）
		'b', 'B'			general							如果参数arg为null，则结果为“false”。如果arg是boolean或Boolean，则结果是String.valueOf(arg)返回的字符串。否则，结果为“true”。
		'h', 'H'			general							如果参数arg为null，则结果为“null”。否则，通过调用Integer.toHexString(arg.hashCode())获得结果。
		's', 'S'			general							如果参数arg为null，则结果为“null”。如果arg实现了Formattable接口，那么将调用arg.formatTo。否则，通过调用arg.toString()获得结果。
		'c', 'C'			character						结果是一个Unicode字符
		'd'					integral						结果被格式化为十进制整数。
		'o'					integral						结果被格式化为八进制整数。
		'x', 'X'			integral						结果的格式为十六进制整数。
		'e', 'E'			floating point					结果在计算机科学记数法中被格式化为十进制数。
		'f'					floating point					结果被格式化为十进制数字。
		'g', 'G'			floating point					根据精度和舍入后的值，结果采用计算机科学记数法或十进制格式格式化。
		'a', 'A'			floating point					结果被格式化为十六进制浮点数，带有有效位和指数。BigDecimal类型不支持此转换，尽管后者属于浮点参数类别。
		't', 'T'			date/time						日期和时间转换字符的前缀。请参见日期/时间转换。
		'%'					percent							结果是文本“%”（'\u0025'）
		'n'					line separator					结果是特定于平台的行分隔符	
		===============================================================================================	
		未显式定义为转换的任何字符都是非法的，并保留用于将来的扩展。
		

	3、Date/Time	转换
		以下日期和时间转换后缀字符是为“t”和“T”转换定义的。这些类型与GNU日期和POSIX strftime（3c）定义的类型相似，但不完全相同。提供额外的转换类型以访问Java特定功能（例如，'L'表示秒内的毫秒数）。	
		
		以下转换字符用于格式化时间：
		===================================================================================================
		'H'	24小时制时钟的一天中的一个小时，格式为两位数，必要时带前导零，即00-23。
		'I'	12小时制时钟的小时，格式为两位数字，必要时带前导零，即01-12。
		'k'	24小时制，即0-23。
		'l'	12小时制，即1-12小时制。
		'M'	小时内的分钟，格式为两位数，必要时以零开头，即00-59。
		'S'	分钟内的秒数，根据需要格式化为两位数字，前导零，即00-60（“60”是支持闰秒所需的特殊值）。
		'L'	秒内的毫秒，格式为三位数字，必要时带前导零，即000-999。
		'N'	纳秒在秒内，格式为9位数字，必要时带前导零，即000000000-999999999。
		'p'	小写的特定于区域的上午或下午标记，例如“am”或“pm”。使用转换前缀“t”将此输出强制为大写。
		'z'	RFC 822样式的数值时区与GMT(格林尼治标准时间)的偏移量，例如-0800。此值将根据夏令时的需要进行调整。对于long、Long和Date，使用的时区是Java虚拟机实例的默认时区。
		'Z'	表示时区缩写的字符串。此值将根据夏令时的需要进行调整。对于long、Long和Date，使用的时区是Java虚拟机实例的默认时区。格式化程序的区域设置将取代参数的区域设置（如果有）。
		's'	从1970年1月1日00:00:00 UTC开始的新纪元开始的秒数，即Long.MIN_VALUE/1000 到 Long.MAX_VALUE/1000。
		'Q'	从1970年1月1日00:00:00 UTC开始的时间（即从Long.MIN_VALUE 到 Long.MAX_VALUE）开始的毫秒数。	
		
		以下转换字符用于设置日期格式：
		===================================================================================================
		'B'	特定于区域设置的完整月份名称，例如"January"（一月）, "February"（二月）
		'b'	特定于区域设置的缩写月份名称，例如"Jan", "Feb"。
		'h'	和'b'一样。
		'A'	特定于区域的一周中某一天的全名，例如"Sunday"（星期日）, "Monday"（星期一）
		'a'	特定于区域设置的一周中某一天的短名称，例如"Sun"（星期日）, "Mon"（星期一）。
		'C'	四位数年份除以100，格式为两位数，必要时前导零，即00-99
		'Y'	年份，格式至少为四位数字，必要时带前导零，例如，对于公历，0092等于92 CE。
		'y'	年份的最后两位，根据需要用前导零格式化，即00-99。
		'j'	一年中的某一天，格式为三位数字，必要时带前导零，例如，公历为001-366。
		'm'	月，格式为两位数，必要时带前导零，即01-13。
		'd'	每月的某一天，格式为两位数，必要时带前导零，即01-31
		'e'	每月的某一天，格式为两位数，即1-31。	
		
		以下转换字符用于格式化常用的日期/时间组合：
		===================================================================================================
		'R'	24小时制时钟的时间格式为"%tH:%tM"
		'T'	24小时时钟的时间格式为"%tH:%tM:%tS"
		'r'	12小时时钟的时间格式为"%tI:%tM:%tS %Tp"。上午或下午标记（'%Tp'）的位置可能取决于区域设置。
		'D'	日期格式为"%tm/%td/%ty"。
		'F'	ISO 8601完成日期格式为"%tY-%tm-%td"
		'c'	日期和时间格式为"%ta %tb %td %tT %tZ %tY"，例如"Sun Jul 20 16:17:00 EDT 1969"。		
		
		未明确定义为日期/时间转换后缀的任何字符都是非法的，并保留用于将来的扩展。
	
	4、标记（Flags）
		下表总结了支持的标志。y表示所示参数类型支持该标志。
		====================================================================================================================================
		Flag	General		Character	Integral	Floating Point	Date/Time	Description
		'-'		y			y			y				y			y			结果保持左对齐（left-justified）
		'#'		y1			-			y3				y			-			结果应使用依赖于转换的替代形式
		'+'		-			-			y4				y			-			结果将始终包含一个符号
		' '		-			-			y4				y			-			结果将包含正值的前导空格
		'0'		-			-			y				y			-			结果将被零填充
		','		-			-			y2				y5			-			结果将包含特定于区域设置的分组分隔符
		'('		-			-			y4				y5			-			结果将用括号括起负数。
		====================================================================================================================================
		1 	取决于Formattable的定义。
		2 	仅针对'd'转换
		3 	仅针对'o'、'x'、和'X'转换。
		4 	对于'd'、'o'、'x'、和'X'转换应用于BigInteger或'd'应用于byte、Byte、short、Short、int 、Integer、long 和 Long。
		5 	仅针对'e'、'E'、'f'、'g' 和 'G'转换。
		未显式定义为标志的任何字符都是非法的，并保留用于将来的扩展。
	
	5、宽度（Width）
		宽度是要写入输出的最小字符数。对于行分隔符转换，宽度不适用；如果提供了宽度，则将引发异常。
	
	6、精密度（Precision）
		对于General参数类型，精度是要写入输出的最大字符数。
		对于floating-point（浮点）转换类型，'a', 'A', 'e', 'E', 和 'f' ，精度是基数点后的小数位数。如果转换为'g'或 'G'，则精度是四舍五入后结果大小中的位数总数。
		对于Character（字符）、Integral（整数）和Date/Time（日期/时间）参数类型以及百分比和行分隔符转换，精度对它们不适用；如果提供精度，则将引发异常。
				
	7、参数索引（Argument Index）	
		参数索引是一个十进制整数，指示参数在参数列表中的位置。第一个参数由“1$”引用，第二个参数由“2$”引用，等等。
		按位置引用参数的另一种方法是使用'<' ('\u003c') 标志，这将导致重新使用上一个格式说明符的参数。例如，以下两个语句将生成相同的字符串：
			Calendar c = ...;
			String s1 = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c);		
			String s2 = String.format("Duke's Birthday: %1$tm %<te,%<tY", c);
	
二、详情（Details）
	本节旨在提供格式化的行为详细信息，包括条件和异常、支持的数据类型、本地化以及标志、转换和数据类型之间的交互。有关格式化概念的概述，请参阅摘要
	未明确定义为conversions、date/time转换后缀或标志的任何字符都是非法的，并保留用于将来的扩展。在格式字符串中使用此类字符将导致引发UnknownFormatConversionException异常或UnknownFormatFlagsException异常。
	如果格式说明符包含不适用于相应参数的转换字符，则将引发IllegalFormatConversionException异常。
	所有指定的异常都可以由Formatter的任何格式方法以及任何格式convenience方法（如String.format和PrintStream.printf）引发。
	由大写字符（即'B', 'H', 'S', 'C', 'X', 'E', 'G', 'A', 和 'T'）表示的转换与相应小写转换字符的转换相同，但结果根据当前区域设置的规则转换为大写。结果等效于以下对String.toUpperCase()的调用。
		out.toUpperCase() 
	
	1、General（常规类型转换）
		以下常规转换可应用于任何参数类型：
		'b'	'\u0062'	生成Boolean.toString(boolean)返回的“true”或“false”。如果参数为null，则结果为“false”。如果参数是boolean或Boolean值，则结果是String.valueOf()返回的字符串。否则，结果为“true”。
						如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。		
		'B'	'\u0042'	'b'的大写形式。
		'h'	'\u0068'	生成表示对象哈希代码值的字符串。如果参数arg为null，则结果为“null”。否则，通过调用Integer.toHexString(arg.hashCode())获得结果。
						如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。
		'H'	'\u0048'	'h'的大写形式。
		's'	'\u0073'	生产字符串。如果参数为null，则结果为“null”。如果参数实现了Formattable接口，则调用其formatTo方法。否则，将通过调用参数的toString()方法来获得结果。
						如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。
		'S'	'\u0053'	's'的大写形式。
		
		以下标志适用于常规转换：		
		'-'	'\u002d'	左对齐输出。转换值的末尾将根据需要添加空格（“\u0020”），以填充字段的最小宽度。如果未提供宽度，则将引发MissingFormatWidthException。如果未给出此标志，则输出将右对齐。
		'#'	'\u0023'	要求输出使用替代形式。表单的定义由转换指定。
		宽度是要写入输出的最小字符数。如果转换值的长度小于宽度，则输出将被' ' ('\u0020') 填充，直到字符总数等于宽度。默认情况下，填充在左侧。如果给出了“-”标志，则填充将在右侧。如果没有指定宽度，则没有最小值。
		精度是要写入输出的最大字符数。精度在宽度之前应用，因此即使宽度大于精度，输出也将被截断为精度字符。如果未指定精度，则字符数没有显式限制。
	
	2、Character（字符类型转换）
		此转换可应用于char和Character。当Character.isValidCodePoint(int)返回true时，它也可以应用于byte, Byte, short, Short, int 和 Integer类型。如果返回false，则将引发IllegalFormatCodePointException异常。
		'c'	'\u0063'	将参数格式化为Unicode字符，如Unicode字符表示中所述。在参数表示补充字符的情况下，这可能不止一个16位字符。
						如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。		
		'C'	'\u0043'	'c'大写形式。
		'-'标志适用常规转换定义。如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。
		宽度（width）定义适用常规转换。
		精度（precision）不适用。如果指定了精度，则将引发IllegalFormatSprecisionException异常。
	
	3、Numeric（数字类型转换）
		数字转换分为以下类别：
			1、Byte, Short, Integer, and Long
			2、BigInteger
			3、Float and Double
			4、BigDecimal
		数字类型将根据以下算法进行格式化：
		● 数字定位算法
		 在获取整数部分、小数部分和指数（适用于数据类型）的数字后，应用以下转换：
		 	1、字符串中的每个数字字符d都替换为一个特定于区域设置（locale）的数字，该数字是相对于当前区域设置的零位z计算的；即d-'0'+z。
		 	2、如果存在十进制分隔符，则替换特定于区域设置的十进制分隔符
		 	3、如果给定了',' ('\u002c')标志，则通过扫描字符串的整数部分（从最低有效数字到最高有效数字），并按照区域设置（locale）分组大小定义的间隔插入一个特定于区域设置（locale）的分组分隔符，来插入特定于区域设置（locale）的分组分隔符。
			4、如果给定了 '0' 标志，则在符号字符（如果有）之后和第一个非零数字之前插入特定于区域设置（locale）的零位，直到字符串的长度等于请求的字段宽度。
			5、如果该值为负数，并且给出了'('标志，则会在前面加上 '('（'\u0028'），并附加一个')' （'\u0029'）。
			6、如果该值为负（或浮点负零），且未给出'('标志，则会预先准备一个'-' ('\u002d')。
			7、如果给定了'+'标志，并且该值为正或零（或浮点正零），则会预先准备一个 '+' ('\u002b')。
		如果值为NaN或正无穷大，则分别输出文本字符串"NaN"或"Infinity"。如果值为负无穷大，则输出将为"(Infinity)"，如果给定'('标志，否则输出将为"-Infinity"。这些值未本地化。
		
		● Byte, Short, Integer, and Long
		以下转换可适用于byte, Byte, short, Short, int and Integer, long, 和 Long。
		===============================================================================================================================================================
		'd'	'\u0064'	将参数格式化为十进制整数。采用定位算法。如果给定了'0'标志且该值为负数，则零填充将出现在符号之后。如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'o'	'\u006f'	将参数格式化为以8为基数的整数（八进制）。未应用本地化。如果x为负，则结果将是一个无符号的值，该值加上2n，其中n是Byte, Short, Integer, 或Long类对象（视情况而定）中静态SIZE字段返回的类型中的位数。
						如果给出了'#'标志，则输出将始终以基数指示符 '0'开头（八进制前缀）。如果给定了'0'标志，则输出将用前导零填充到任何符号指示后的字段宽度。
						如果给定了'(', '+', '  ', 或 ',' 标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'x'	'\u0078'	将参数格式设置为以16为基数的整数（十六进制）。未应用本地化。如果x为负，则结果将是一个无符号的值，该值加上2n，其中n是Byte, Short, Integer, 或Long类对象（视情况而定）中静态SIZE字段返回的类型中的位数。
						如果给出了'#'标志，则输出将始终以基数指示器'0x'开头。如果给定了'0'标志，则输出将在基数指示器或符号（如果存在）后用前导零填充到字段宽度。
						如果给定了'(', '  ', '+', 或 ',' 标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'X'	'\u0058'	“x”的大写形式。表示数字的整个字符串将被转换为大写，包括'x'（如果有）和所有十六进制数字'a'-'f'（'\u0061'-'\u0066'）。
		
		如果转换为'o', 'x',或 'X'，并且同时给出了'#'和'0'标志，则结果将包含基数指示器（'0'表示八进制，'0x'或'0X'表示十六进制）、一些零（基于宽度）和值。
		如果没有给出'-'标志，则符号前面将出现空格填充。
		
		以下标志适用于整数数值转换：
		===============================================================================================================================================================
		'+'	'\u002b'	要求输出包含所有正数的正符号。如果未给定此标志，则只有负值才会包含符号。如果同时给出'+'和' '标志，则将引发IllegalFormatFlagsException异常。
		
		' '	'\u0020'	要求输出包含一个单独的额外空格('\u0020')用于非负值。如果同时给出'+'和' '标志，则将引发IllegalFormatFlagsException异常。		
		
		'0'	'\u0030'	要求在任何符号或基数指示符之后用前导零填充输出，直至最小字段宽度，转换NaN或infinity（无穷大）时除外。如果未提供宽度，则将引发MissingFormatWidtheException异常。
		
		','	'\u002c'	要求输出包含特定于区域设置（locale）的组分隔符，如本地化算法的"group"部分所述。
		
		'('	'\u0028'	要求输出在负值前加上'(' ('\u0028')并附加一个')' ('\u0029')。
		
		如果没有给定标志，默认格式如下：			
			● 输出在宽度内右对齐。	
			● 负数以'-'开头('\u002d')。
			● 正数和零不包含符号或额外的前导空格。	
			● 不包括分组分隔符。
		宽度是要写入输出的最小字符数。这包括任何符号、数字、分组分隔符、基数指示符和括号。如果转换值的长度小于宽度，则输出将用空格（“\u0020”）填充，直到字符总数等于宽度。默认情况下，填充在左侧。如果给出了“-”标志，则填充将在右侧。如果没有指定宽度，则没有最小值。
		精度（precision）不适用。如果指定了精度，则将引发IllegalFormatSprecisionException异常。
		
		
		● BigInteger
		以下转换可应用于BigInteger。
		===============================================================================================================================================================
		'd'	'\u0064'	要求将输出格式化为十进制整数。采用定位算法。如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'o'	'\u006f'	要求将输出格式化为8进制整数。未应用本地化。如果x为负数，则结果将是一个以“-”开头的有符号值（“\u002d”）。此类型允许有符号输出，因为与基元类型不同，在不假定显式数据类型大小的情况下，无法创建无符号等效类型。
						如果x为正或零，并且给出了'+'标志，那么结果将以'+'('\u002b')开头。如果给定了'#'标志，则输出将始终以'0'前缀开头。
						如果给定了'0'标志，则输出将用前导零填充到任何符号指示后的字段宽度。如果给定了',' 标志，则将引发FormatFlagsConversionMismatchException异常。
		'x'	'\u0078'	要求将输出格式化为16十六进制整数。未应用本地化。如果x为负数，则结果将是一个以'-'开头的有符号值（'\u002d'）。此类型允许有符号输出，因为与基元类型不同，在不假定显式数据类型大小的情况下，无法创建无符号等效类型。
						如果x为正或零，并且给出了'+'标志，那么结果将以'+''+'('\u002b')开头。如果给出了'#'标志，则输出将始终以基数指示器'0x'开头。
						如果给定了'0'标志，则输出将在基数指示器或符号（如果存在）后用前导零填充到字段宽度。如果给定了',' 标志，则将引发FormatFlagsConversionMismatchException异常。
						
		'X'	'\u0058'	“x”的大写形式。表示数字的整个字符串将被转换为大写，包括'x'（如果有）和所有十六进制数字'a'-'f'（'\u0061'-'\u0066'）。
		
		如果转换为“o”、“x”或“x”，并且同时给出了“#”和“0”标志，则结果将包含基本指示符（“0”表示八进制，“0x”或“0X”表示十六进制）、一些零（基于宽度）和值。
		如果给定了“0”标志且该值为负数，则零填充将出现在符号之后。
		如果没有给出“-”标志，则符号前面将出现空格填充。
		为Byte, Short, Integer, 和 Long应用定义的所有标志。没有给定标志时的默认行为与Byte, Short, Integer, 和 Long相同。
		宽度的规格与Byte, Short, Integer, 和 Long的定义相同。
		精度（precision）不适用。如果指定了精度，则将引发IllegalFormatSprecisionException异常。
		
		
		● Float and Double
		以下转换可应用于float, Float, double 和 Double。
		===============================================================================================================================================================
		'e'	'\u0065'	要求使用计算机科学记数法格式化输出。采用定位算法。幅度m的格式取决于其值。如果m是NaN或无穷大，则分别输出文本字符串"NaN"或"Infinity"。这些值未本地化。如果m为正零或负零，则指数将为“+00”。否则，结果是一个字符串，它表示参数的符号和大小（绝对值）。符号的格式在本地化算法中进行了描述。幅度m的格式取决于其值。
						设n为唯一整数，使10n<=m<10n+1；然后设a为m和10n的数学精确商，使1<=a<10。然后，将幅度表示为a的整数部分，表示为一个十进制数字，然后是十进制分隔符，然后是表示a的小数部分的十进制数字，然后是指数符号“e”（'\u0065'），然后是指数的符号，最后是表示n为十进制整数的十进制数字，由方法Long.toString(long, int)生成，零填充以包含至少两个数字。
						结果中m或a的小数部分的位数等于精度。如果未指定精度，则默认值为6。如果精度小于Float.toString(float) 或Double.toString(double)返回的字符串中小数点后出现的位数，则使用舍入半向上算法对值进行舍入。否则，可以附加零以达到精度。对于值的规范表示，请根据需要使用Float.toString(float)或Double.toString(double)。
						如果给定了 ','标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'E'	'\u0045'	'e'的大写形式。 指数符号将为'E' ('\u0045')。
		
		'g'	'\u0067'	要求输出的格式为以下所述的一般科学符号。采用定位算法。对精度进行舍入后，生成的幅度m的格式取决于其值。如果m大于或等于10-4但小于10精度，则以十进制格式表示。如果m小于10-4或大于或等于10精度，则用计算机科学记数法表示。
						m中有效位数的总数等于精度。如果未指定精度，则默认值为6。如果精度为0，则取1。如果给定了“#”标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'G'	'\u0047'	'g'的大写形式。
		
		'f'	'\u0066'	要求使用十进制格式格式化输出。采用定位算法。结果是一个字符串，它表示参数的符号和大小（绝对值）。符号的格式在本地化算法中进行了描述。幅度m的格式取决于其值。如果m "NaN"或"Infinity"，将分别输出文本字符串"NaN"或"Infinity"。这些值未本地化。
						幅度的格式为m的整数部分，没有前导零，后面是小数点分隔符，后面是表示m的小数部分的一个或多个十进制数字。结果中m或a的小数部分的位数等于精度。如果未指定精度，则默认值为6。
						如果精度小于Float.toString（float）或Double.toString（double）返回的字符串中小数点后出现的位数，则使用舍入半向上算法对值进行舍入。否则，可以附加零以达到精度。对于值的规范表示，请根据需要使用Float.toString（float）或Double.toString（double）。
		
		'a'	'\u0061'	要求输出以十六进制指数形式格式化。未应用本地化。结果是一个字符串，它表示参数x的符号和大小（绝对值）。如果x为负值或负值，则结果将以'-'('\u002d')开头。如果x为正值或为正值，并给出'+'标志，则结果将以'+' ('\u002b')开头。幅度m的格式取决于其值。
						如果值为"NaN"或"Infinity"，则分别输出文本字符串"NaN"或"Infinity"。如果m为零，则用字符串“0x0.0p0”表示。
						如果m是一个具有规范化表示的double值，则子字符串用于表示有效位和指数字段。有效位由字符"0x1."表示，然后是有效位其余部分的十六进制表示，作为分数。指数由'p' ('\u0070') 和无偏差指数的十进制字符串表示，就好像是通过对指数值调用Integer.toString生成的一样。如果指定了精度，则该值将四舍五入到给定的十六进制数。
						如果m是具有次正规表示的double精度值，则除非指定精度在1到12范围内（包括1到12），否则有效位由字符'0x0.'表示，后跟有效位其余部分的十六进制表示作为分数，指数由'p-1022'表示。如果精度在间隔[1，12]内，则对次正常值进行规格化，使其以字符'0x1.'开头，四舍五入到精度的十六进制位数，并相应调整指数。注意，在次正规有效位中必须至少有一个非零数字。
						如果给定了'(' 或 ',' 标志，则将引发FormatFlagsConversionMismatchException异常。
		'A'	'\u0041'	'a'大写形式。表示数字的整个字符串将转换为大写，包括'x' ('\u0078')和'p' ('\u0070'以及所有十六进制数字'a' - 'f' ('\u0061' - '\u0066')。		
		
		为Byte, Short, Integer, 和 Long应用定义的所有标志。
		如果给定了 '#' 标志，则小数分隔符将始终存在。			
		如果没有给定标志，默认格式如下：	
			● 输出在宽度内右对齐。	
			● 负数以'-'开头。
			● 正数和零不包含符号或额外的前导空格。	
			● 不包括分组分隔符。
			● 只有在小数点后有一个数字时，小数点分隔符才会出现。
		宽度（width）是要写入输出的最小字符数。这包括任何符号、数字、分组分隔符、小数点分隔符、指数符号、基数指示符、括号以及表示infinity（无穷大）和NaN（如适用）的字符串。如果转换值的长度小于宽度，则输出将用空格 ('\u0020')填充，直到字符总数等于宽度。默认情况下，填充在左侧。如果给出了“-”标志，则填充将在右侧。如果没有指定宽度，则没有最小值。
		如果转换为“e”、“E”或“f”，则精度为小数点后的位数。如果未规定精度，则假定精度为6。
		如果转换为“g”或“G”，则精度是四舍五入后结果数量级中有效数字的总数。如果未指定精度，则默认值为6。如果精度为0，则取1。
		如果转换为“a”或“A”，则精度为基数后的十六进制数字。如果不提供精度，则将输出Double.toHexString(double)返回的所有数字。
		
		● BigDecimal
		以下转换可以应用bigDecimal。
		===============================================================================================================================================================
		'e'	'\u0065'	要求使用计算机科学记数法格式化输出。采用定位算法。量级m的格式取决于其值。如果m为正零或负零，则指数将为“+00”。否则，结果是一个字符串，它表示参数的符号和大小（绝对值）。符号的格式在本地化算法中进行了描述。量级m的格式取决于其值。
						设n为唯一整数，使10n<=m<10n+1；然后设a为m和10n的数学精确商，使1<=a<10。然后，将震级表示为a的整数部分，表示为一个十进制数字，然后是十进制分隔符，然后是表示a的小数部分的十进制数字，然后是指数符号“e”（'\u0065'），然后是指数的符号，最后是表示n为十进制整数的十进制数字，由Long.toString(long, int)方法生成，零填充以包含至少两个数字。
						结果中m或a的小数部分的位数等于精度。如果未指定精度，则默认值为6。如果精度小于小数点右边的位数，则将使用舍入半向上算法对值进行舍入。否则，可以附加零以达到精度。对于值的规范表示，请使用BigDecimal.toString()。如果给定了',' 标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'E'	'\u0045'	'e'大写形式。 指数符号将为'E' ('\u0045')。
		
		'g'	'\u0067'	要求输出的格式为以下所述的一般科学符号。采用定位算法。对精度进行舍入后，生成的量级m的格式取决于其值。如果m大于或等于10-4但小于10精度，则以十进制格式表示。
						如果m小于10-4或大于或等于10精度，则用计算机科学记数法表示。m中有效位数的总数等于精度。如果未指定精度，则默认值为6。如果精度为0，则取1。如果给定了 '#' 标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'G'	'\u0047'	'g'的大写形式。
		
		'f'	'\u0066'	要求使用十进制格式格式化输出。采用定位算法。结果是一个字符串，它表示参数的符号和大小（绝对值）。符号的格式在本地化算法中进行了描述。量级m的格式取决于其值。
						量级的格式为m的整数部分，没有前导零，后面是小数点分隔符，后面是表示m的小数部分的一个或多个十进制数字。结果中m或a的小数部分的位数等于精度。如果未指定精度，则默认值为6。如果精度小于小数点右边的位数，则将使用舍入半向上算法对值进行舍入。否则，可以附加零以达到精度。对于值的规范表示，请使用BigDecimal.toString()。
		
		为Byte, Short, Integer, 和 Long应用定义的所有标志。
		如果给定了 '#' 标志，则小数分隔符将始终存在。
		没有给定标志时的默认行为与Float和Double相同。
		宽度和精度的规格与Float和Double的定义相同。
		
		
	5、Date/Time
		此转换可应用于long, Long, Calendar, Date 和TemporalAccessor
		't'	'\u0074'	日期和时间转换字符的前缀。
		'T'	'\u0054'	't'大写形式。
		以下日期和时间转换字符后缀是为“t”和“T”转换定义的。这些类型与GNU日期和POSIX strftime(3c)定义的类型相似，但不完全相同。提供额外的转换类型以访问Java特定功能（例如，'L'表示秒内的毫秒数）。
		以下转换字符用于格式化时间：
		===============================================================================================================================================================
		'H'	'\u0048'	24小时制时钟的一天中的一个小时，格式为两位数，必要时带前导零，即00-23。00表示午夜。
		'I'	'\u0049'	12小时制时钟的小时，格式为两位数字，必要时带前导零，即01-12。01表示一点钟（上午或下午）。
		'k'	'\u006b'	24小时制，即0-23。0表示午夜。
		'l'	'\u006c'	12小时制，即1-12小时制。1表示一点钟（上午或下午）。
		'M'	'\u004d'	小时内的分钟，格式为两位数，必要时以零开头，即00-59。
		'S'	'\u0053'	分钟内的秒数，根据需要格式化为两位数字，前导零，即00-60（“60”是支持闰秒所需的特殊值）。
		'L'	'\u004c'	秒内的毫秒，格式为三位数字，必要时带前导零，即000-999。
		'N'	'\u004e'	纳秒在秒内，格式为9位数字，必要时带前导零，即000000000-999999999。这个值的精度受到底层操作系统或硬件分辨率的限制。
		'p'	'\u0070'	小写的特定于区域（locale）的上午或下午标记，例如“am”或“pm”。使用转换前缀“t”将此输出强制为大写。（注意，'p'产生小写输出。这与生成大写输出的GNU date和POSIX strftime(3c)不同。）
		'z'	'\u007a'	RFC 822样式的数值时区与格林尼治标准时间的偏移量，例如-0800。此值将根据夏令时的需要进行调整。对于 long, Long, 和 Date，使用的时区是Java虚拟机实例的默认时区。
		'Z'	'\u005a'	表示时区缩写的字符串。此值将根据夏令时的需要进行调整。对于long、Long和Date，使用的时区是Java虚拟机实例的默认时区。格式化程序的区域设置（locale）将取代参数的区域设置（如果有）。
		's'	'\u0073'	从1970年1月1日00:00:00 UTC开始的新纪元开始的秒数，即Long.MIN_VALUE/1000到Long.MAX_VALUE/1000。
		'Q'	'\u004f'	从1970年1月1日00:00:00 UTC开始的时间（即从Long.MIN_VALUE值到Long.MAX_VALUE）开始的毫秒数。这个值的精度受到底层操作系统或硬件分辨率的限制。	
		
		以下转换字符用于设置日期格式：
		===============================================================================================================================================================
		'B'	特定于区域设置的完整月份名称，例如"January"（一月）, "February"（二月）
		'b'	特定于区域设置的缩写月份名称，例如"Jan", "Feb"。
		'h'	和'b'一样。
		'A'	特定于区域的一周中某一天的全名，例如"Sunday"（星期日）, "Monday"（星期一）
		'a'	特定于区域设置的一周中某一天的短名称，例如"Sun"（星期日）, "Mon"（星期一）。
		'C'	四位数年份除以100，格式为两位数，必要时前导零，即00-99
		'Y'	年份，格式至少为四位数字，必要时带前导零，例如，对于公历，0092等于92 CE。
		'y'	年份的最后两位，根据需要用前导零格式化，即00-99。
		'j'	一年中的某一天，格式为三位数字，必要时带前导零，例如，公历为001-366。
		'm'	月，格式为两位数，必要时带前导零，即01-13。
		'd'	每月的某一天，格式为两位数，必要时带前导零，即01-31
		'e'	每月的某一天，格式为两位数，即1-31。		
		
		以下转换字符用于格式化常用的日期/时间组合。
		===============================================================================================================================================================
		'R'	24小时制时钟的时间格式为"%tH:%tM"
		'T'	24小时时钟的时间格式为"%tH:%tM:%tS"
		'r'	12小时时钟的时间格式为"%tI:%tM:%tS %Tp"。上午或下午标记（'%Tp'）的位置可能取决于区域设置。
		'D'	日期格式为"%tm/%td/%ty"。
		'F'	ISO 8601完成日期格式为"%tY-%tm-%td"
		'c'	日期和时间格式为"%ta %tb %td %tT %tZ %tY"，例如"Sun Jul 20 16:17:00 EDT 1969"。	
		
		为General常规转换定义的“-”标志适用。如果给定了 '#' 标志，则将引发FormatFlagsConversionMismatchException异常。
		宽度（width）是要写入输出的最小字符数。如果转换值的长度小于宽度，则输出将用空格（“\u0020”）填充，直到字符总数等于宽度。默认情况下，填充在左侧。如果给出了“-”标志，则填充将在右侧。如果没有指定宽度，则没有最小值。
		精度（precision）不适用。如果指定了精度，则将引发IllegalFormatPrecisionException异常。
		
	6、Percent（百分比）
		转换与任何参数都不对应。
		'%'		结果是文本“%”（'\u0025'）。宽度是要写入输出的最小字符数，包含“%”。如果转换值的长度小于宽度，则输出将用空格（“\u0020”）填充，直到字符总数等于宽度。衬垫在左边。如果未指定宽度，则只输出“%”。
				为常规转换定义的“-”标志适用此处。如果提供了任何其他标志，则将引发FormatFlagsConversionMismatchException异常。
				精度（precision）不适用。如果指定了精度，则将引发IllegalFormatPrecisionException异常。
		
	7、Line Separator（行分隔符）
		转换与任何参数都不对应。
		'n'		System.getProperty("line.separator")返回的特定于平台的行分隔符。
				Flags（转换标记）、 width（宽度） 和  precision（精度）都不适用。如果提供的话分别引发IllegalFormatFlagsException、IllegalFormatWidthException和IllegalFormatPrecisionException异常。
		
	8、Argument Index（参数索引）
		格式说明符可以通过三种方式引用参数：
			1、当格式说明符包含参数索引时，使用显式索引。参数索引是一个十进制整数，指示参数在参数列表中的位置。第一个参数由“1$”引用，第二个参数由“2$”引用等。一个参数可能被多次引用。
				例如：
				formatter.format("%4$s %3$s %2$s %1$s %4$s %3$s %2$s %1$s","a", "b", "c", "d")  // -> "d c b a d c b a"
			2、当格式说明符包含 '<' ('\u003c') 标志时使用相对索引，该标志会导致重新使用上一个格式说明符的参数。如果没有以前的参数，则会引发MissingFormatArgumentException异常。
				formatter.format("%s %s %<s %<s", "a", "b", "c", "d")  // -> "a b b b"  
				//“c”和“d”被忽略，因为它们没有被引用
			3、当格式说明符既不包含参数索引也不包含“<”标志时，使用普通索引。使用普通索引的每个格式说明符都被分配一个顺序隐式索引到参数列表中，该参数列表独立于显式索引或相对索引使用的索引。
				formatter.format("%s %s %s %s", "a", "b", "c", "d")  // -> "a b c d"
		可以有一个格式字符串，它使用所有形式的索引，例如：
			formatter.format("%2$s %s %<s %s", "a", "b", "c", "d") // -> "b a a b"
			//“c”和“d”被忽略，因为它们没有被引用
		参数最大数受Java Java虚拟机规范定义的Java阵列的最大尺寸的限制。如果参数索引与可用参数不对应，则会引发MissingFormatArgumentException异常。
		如果参数多于格式说明符，则忽略多余的参数。
		除非另有指定，否则将空参数传递给此类中的任何方法或构造函数将导致引发NullPointerException异常。
		
		
		
	类定义	：public final class Formatter implements Closeable, Flushable
	实现接口	：Closeable, Flushable
------------------------------------------------------------------------------------------------------------------------------------------------------		
构造器：
	public Formatter()
		 构造新的格式字符串解释器。格式化输出的目标是一个StringBuilder，它可以通过调用out()来检索，其当前内容可以通过调用toString()转换为字符串。使用的区域设置（locale）是Java虚拟机实例的格式化的默认区域设置。
	public Formatter(File file)
		使用指定的文件构造新的格式字符串解释器。使用的字符集是Java虚拟机实例的默认字符集。使用的区域设置（locale）是Java虚拟机实例的格式化的默认区域设置。
		 【Throws】：
		 	SecurityException 如果存在安全管理器，并且checkWrite(file.getPath())拒绝对该文件的写访问
		 	FileNotFoundException 如果给定的文件对象不表示现有的可写常规文件，并且无法创建该名称的新常规文件，或者在打开或创建文件时发生其他错误。
	public Formatter(File file, String csn)
		使用指定的文件和字符集构造新的格式字符串解释器。使用的区域设置（locale）是Java虚拟机实例的格式化的默认区域设置。
		【Throws】：
			FileNotFoundException 如果给定的文件对象不表示现有的可写常规文件，并且无法创建该名称的新常规文件，或者在打开或创建文件时发生其他错误。
		 	SecurityException 如果存在安全管理器，并且checkWrite(file.getPath())拒绝对该文件的写访问
		 	UnsupportedEncodingException 如果不支持命名字符集csn
	public Formatter(OutputStream os)
		使用指定的输出流构造新的格式字符串解释器。使用的字符集是Java虚拟机实例的默认字符集。使用的区域设置是Java虚拟机实例的格式化的默认区域设置。
	public Formatter(OutputStream os, String csn)
		使用指定的输出流和字符集构造新的格式化程序。使用的区域设置是Java虚拟机实例的格式化的默认区域设置。
		【Throws】：
			UnsupportedEncodingException 如果不支持命名字符集csn
	public Formatter(OutputStream os, String csn, Locale l)
		使用指定的输出流、字符集和区域设置构造新的格式化程序。
		【Throws】：
			UnsupportedEncodingException 如果不支持命名字符集csn
	public Formatter(PrintStream ps)
		使用指定的打印流构造新的格式化程序。使用的区域设置是Java虚拟机实例的格式化的默认区域设置。字符被写入给定的PrintStream对象，因此使用该对象的字符集进行编码。
	public Formatter(Appendable a)
		构造具有指定目标的新格式化程序。使用的区域设置是Java虚拟机实例的格式化的默认区域设置。
	public Formatter(Appendable a, Locale l)
		使用指定的目标和区域设置构造新的格式化程序。
	public Formatter(String fileName)
		使用指定的文件名构造新的格式化程序。使用的字符集是Java虚拟机实例的默认字符集。使用的区域设置是Java虚拟机实例的格式化的默认区域设置。
		【Throws】：
		 	SecurityException 如果存在安全管理器，并且checkWrite(file.getPath())拒绝对该文件的写访问
		 	FileNotFoundException 如果给定的文件对象不表示现有的可写常规文件，并且无法创建该名称的新常规文件，或者在打开或创建文件时发生其他错误。
	public Formatter(String fileName, String csn)
		使用指定的文件名和字符集构造新的格式化程序。使用的区域设置是Java虚拟机实例的格式化的默认区域设置。
		【Throws】：
			FileNotFoundException 如果给定的文件对象不表示现有的可写常规文件，并且无法创建该名称的新常规文件，或者在打开或创建文件时发生其他错误。
		 	SecurityException 如果存在安全管理器，并且checkWrite(file.getPath())拒绝对该文件的写访问
		 	UnsupportedEncodingException 如果不支持命名字符集csn
	public Formatter(String fileName, String csn, Locale l)
		使用指定的文件名、字符集和区域设置构造新的格式化程序。
		【Throws】：
			FileNotFoundException 如果给定的文件对象不表示现有的可写常规文件，并且无法创建该名称的新常规文件，或者在打开或创建文件时发生其他错误。
		 	SecurityException 如果存在安全管理器，并且checkWrite(file.getPath())拒绝对该文件的写访问
		 	UnsupportedEncodingException 如果不支持命名字符集csn
	public Formatter(Locale l)
		使用指定的区域设置构造新的格式化程序。格式化输出的目标是一个StringBuilder，它可以通过调用out()来检索，其当前内容可以通过调用toString()转换为字符串。

方法：
	close():void 
		△ 关闭此格式化程序。如果目的地实现了可关闭的接口，那么将调用它的close方法。
		关闭格式化程序允许它释放可能持有的资源（如打开的文件）。如果格式化程序已关闭，则调用此方法无效。
		关闭此格式化程序后，尝试调用除ioException()之外的任何方法都将导致FormatterClosedException异常。
	flush():void 
		△ 刷新此格式化程序。如果目的地实现了可Flushable接口，则将调用其flush方法。刷新格式化程序会将目标中的任何缓冲输出写入基础流。
		【Throws】：
			FormatterClosedException 如果此格式化程序已通过调用其close()方法关闭			
	format(String format, Object ... args):Formatter 
		使用指定的格式字符串和参数将格式化字符串写入此对象的目标。使用的区域设置是在此格式化程序构造期间定义的区域设置。
		【Throws】：
			IllegalFormatException 如果格式字符串包含非法语法、与给定参数不兼容的格式说明符、给定格式字符串的参数不足或其他非法条件。有关所有可能的格式错误的规范，请参阅格式化程序类规范的详细信息部分。
			FormatterClosedException 如果此格式化程序已通过调用其close()方法关闭
	format(Locale l, String format, Object ... args):Formatter 
		使用指定的区域设置、格式字符串和参数将格式化字符串写入此对象的目标。
		【Throws】：
			IllegalFormatException 如果格式字符串包含非法语法、与给定参数不兼容的格式说明符、给定格式字符串的参数不足或其他非法条件。有关所有可能的格式错误的规范，请参阅格式化程序类规范的详细信息部分。
			FormatterClosedException 如果此格式化程序已通过调用其close()方法关闭
	ioException():IOException
		 返回此格式化程序的Appendable最后引发的IOException。如果目标的append()方法从不抛出IOException，则此方法将始终返回null值。
	locale():Locale 
		返回此格式化程序的构造设置的区域设置。具有区域设置参数的此对象的格式方法不会更改此值。
	out():Appendable
		返回输出的目标。
		【Throws】：
			FormatterClosedException 如果此格式化程序已通过调用其close()方法关闭
	toString():String 
		△  返回在输出的目标上调用toString()的结果。例如，以下代码将文本格式化为StringBuilder，然后检索结果字符串：
		   Formatter f = new Formatter();
		   f.format("Last reboot at %tc", lastRebootDate);
		   String s = f.toString();
		   // -> s == "Last reboot at Sat Jan 01 00:00:00 PST 2000"			
		下面与此方法的调用行为完全相同
			out().toString() 
		根据附加字符串的规范，返回的字符串可能包含或不包含写入目标的字符。例如，缓冲区通常在toString()中返回其内容，但流不能返回，因为数据被丢弃。
		【Throws】：
			FormatterClosedException 如果此格式化程序已通过调用其close()方法关闭
		
		
------------------------------------------------------------------------------------------------------------------------------------------------------
附录：
	1、注：文档中的☆符号已过时或淘汰掉的方法。
	2、注：文档中的△符号表示覆盖重写方法。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	