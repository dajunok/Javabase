-------------------------------ServiceLoader<S>-----------------------------------------------------------------------------------------------------------------------
ServiceLoader<S>：服务加载器。【since 1.6】
	<S>	 此加载程序要加载的服务类型
	一个简单提供加载服务的加载设施。	
	服务是一组众所周知的接口和（通常是抽象的）类。服务提供者是服务的特定实现。提供者中的类通常实现接口，并对服务本身定义的类进行子类化。服务提供者可以以扩展的形式安装在Java平台的实现中，即放置在任何通常的扩展目录中的JAR文件。提供者也可以通过将它们添加到应用程序的类路径或其他特定于平台的方法来提供。
	为了进行加载，服务由单个类型（即单个接口或抽象类）表示。（可以使用具体的类，但不建议这样做。）给定服务的提供者包含一个或多个具体的类，这些类使用特定于提供者的数据和代码扩展此服务类型。提供者类通常不是整个提供者本身，而是一个代理，它包含足够的信息来决定提供者是否能够满足特定的请求以及可以根据需要创建实际提供者的代码。提供者类的细节往往是高度特定于服务的；没有单个类或接口可以将它们统一起来，因此这里没有定义此类类型。此工具强制实施的唯一要求是提供者类必须具有无参构造函数，以便在加载期间实例化它们。		
	通过在资源目录META-INF/services中放置提供者配置文件来标识服务提供者。文件名是服务类型的完全限定二进制名称。该文件包含具体提供者类的完全限定的二进制名称列表，每行一个。忽略每个名称周围的空格和制表符以及空行。注释字符是''（'\u0023'，数字符号）；在每行中，第一个注释字符后面的所有字符都将被忽略。文件必须以UTF-8编码。
	如果某个特定的具体提供者类在多个配置文件中命名，或者在同一个配置文件中多次命名，则忽略重复项。命名特定提供者的配置文件不需要与提供者本身位于同一JAR文件或其他分发单元中。提供者必须可以从最初查询以定位配置文件的同一类加载器访问；请注意，这不一定是实际从中加载文件的类加载器。
	提供者被惰性地定位和实例化，也就是说，随需应变。服务加载程序维护到目前为止已加载的提供者的缓存。每次调用迭代器方法都返回一个迭代器，该迭代器首先以实例化顺序生成缓存的所有元素，然后惰性定位和实例化任何剩余的提供者，依次将每个提供者添加到缓存中。可以通过重新加载方法清除缓存。	
	服务加载程序总是在调用方的安全上下文中执行。受信任的系统代码通常应该从特权安全上下文中调用此类中的方法以及它们返回的迭代器的方法。
	这个类的实例对于多个并发线程的使用是不安全的。	
	除非另有指定，否则将空参数传递给此类中的任何方法都将导致引发NullPointerException异常。	
	示例：假设我们有一个服务类型com.example.CodecSet，它用于表示某些协议的编码器/解码器对集。在这种情况下，它是一个抽象类，有两个抽象方法：
		 public abstract Encoder getEncoder(String encodingName);
		 public abstract Decoder getDecoder(String encodingName);	
	如果提供者不支持给定的编码，则每个方法都返回适当的对象或空值。典型的提供者支持多种编码。
	如果com.example.impl.StandardCodecs是Codecset服务的实现，那么它的jar文件也包含一个这样的文件：
		META-INF/services/com.example.CodecSet
	此文件包含一行：
		com.example.impl.StandardCodecs    # Standard codecs
	Codecset类在初始化时创建并保存单个服务实例：	
		 private static ServiceLoader<CodecSet> codecSetLoader = ServiceLoader.load(CodecSet.class);		
	要查找给定编码名称的编码器，它定义了一个静态工厂方法，该方法迭代已知和可用的提供者，仅在找到合适的编码器或遍历完提供者时返回。
		 public static Encoder getEncoder(String encodingName) {
		     for (CodecSet cp : codecSetLoader) {
		         Encoder enc = cp.getEncoder(encodingName);
		         if (enc != null)
		             return enc;
		     }
		     return null;
		 }		
	getDecoder方法的定义类似。	
	用法说明：如果用于提供者加载的类加载程序的类路径包含远程网络URL，则在搜索提供者配置文件的过程中，这些URL将被取消引用。
	此操作是正常的，尽管它可能会导致在Web服务器日志中创建令人费解的条目。但是，如果Web服务器配置不正确，则此操作可能会导致提供者加载算法错误失败。
	当请求的资源不存在时，Web服务器应返回HTTP 404（未找到）响应。然而，在这种情况下，Web服务器有时被错误地配置为返回HTTP200（OK）响应以及有用的HTML错误页。这将导致在此类尝试将HTML页解析为提供者配置文件时引发ServiceConfigurationError异常。这个问题的最佳解决方案是修复错误配置的Web服务器，以返回正确的响应代码（HTTP 404）和HTML错误页。	
		
		
	类定义	：public final class ServiceLoader<S> implements Iterable<S>
	实现接口	：Iterable<S>
------------------------------------------------------------------------------------------------------------------------------------------------------		
Method Summary（方法概要）：
	load(Class<S> service):static <S> ServiceLoader<S> 
		使用当前线程的上下文类加载器为给定的服务类型创建新的ServiceLoader。
		这个便利方法的调用形式：
			ServiceLoader.load(service)
		等效于：
			ServiceLoader.load(service,Thread.currentThread().getContextClassLoader())
	load(Class<S> service,ClassLoader loader):static <S> ServiceLoader<S> 
		为给定的服务类型和类加载器创建新的ServiceLoader。
	loadInstalled(Class<S> service):static <S> ServiceLoader<S> 
		使用扩展类加载器为给定的服务类型创建新的ServiceLoader。
		这个便利方法只需定位扩展类加载器，调用extClassLoader加载器，然后返回
			ServiceLoader.load(service, extClassLoader)
		如果找不到扩展类加载器，则使用系统类加载器；如果没有系统类加载器，则使用引导类加载器。
		此方法仅在需要已安装的提供者时使用。生成的服务将只查找并加载已安装到当前Java虚拟机中的提供者；应用程序的类路径上的提供程序将被忽略。
	iterator():Iterator<S> 
		△ 延迟加载此加载程序服务的可用提供者。
		此方法返回的迭代器首先以实例化顺序生成提供者缓存的所有元素。然后，它惰性地加载并实例化任何剩余的提供者，依次将每个提供者添加到缓存中。
		为了实现惰性，解析可用的提供者配置文件和实例化提供者的实际工作必须由迭代器本身完成。因此，如果提供者配置文件违反了指定的格式，或者指定了无法找到和实例化的提供者类，或者实例化该类的结果不可分配给服务类型，或者如果引发了任何其他类型的异常或错误，则其hasNext和next方法可以引发ServiceConfigurationError异常。或者，当下一个提供者被定位并实例化时，引发任何其他类型的异常或错误。要编写健壮的代码，只需要在使用服务迭代器时捕获ServiceConfigurationError异常。
		如果抛出了这样一个错误，那么随后的迭代器调用将尽最大努力定位和实例化下一个可用的提供者，但一般来说，这种恢复是无法保证的。
		在这些情况下，引发错误的设计说明可能看起来很极端。这种行为的理由是，畸形的提供者配置文件，如畸形的类文件，表明Java虚拟机被配置或正在使用的严重问题。因此，最好是抛出一个错误，而不是试图恢复，甚至更糟的是，静静地失败。
		此方法返回的迭代器不支持删除。调用其移除方法将导致引发UnsupportedOperationException异常。
		向缓存中添加提供者时，迭代器按ClassLoader.getResources(String)方法查找服务配置文件的顺序处理资源。
	reload():void 
		清除此加载程序的提供者缓存，以便重新加载所有提供者。
		调用此方法之后，迭代器方法的后续调用将懒散地从头开始查找和实例化提供者，就像新创建的加载程序所做的那样。
		该方法旨在在新的提供者可以安装到运行的Java虚拟机的情况下使用。
	toString():String 	
		△ 返回描述此服务的字符串。
	
------------------------------------------------------------------------------------------------------------------------------------------------------
附录：
	1、注：文档中的☆符号已过时或淘汰掉的方法。
	2、注：文档中的△符号表示覆盖重写方法。
	3、'::' 关键字：	双冒号可以访问类的构造方法，对象方法，静态方法。就是把方法当做参数传到stream内部，使stream的每个元素都传入到该方法里面执行一下。
	4、单实例：（即单例设计模式）。“一个类有且仅有一个实例，并且自行实例化向整个系统提供。”单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。要实现这一点，可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问。使用工厂方法来限制实例化过程。这个方法应该是静态方法（类方法），因为让类的实例去生成另一个唯一实例毫无意义。
	






















