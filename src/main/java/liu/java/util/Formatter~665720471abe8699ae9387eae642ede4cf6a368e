	4、标记（Flags）
		下表总结了支持的标志。y表示所示参数类型支持该标志。
		====================================================================================================================================
		Flag	General		Character	Integral	Floating Point	Date/Time	Description
		'-'		y			y			y				y			y			结果保持左对齐（left-justified）
		'#'		y1			-			y3				y			-			结果应使用依赖于转换的替代形式
		'+'		-			-			y4				y			-			结果将始终包含一个符号
		' '		-			-			y4				y			-			结果将包含正值的前导空格
		'0'		-			-			y				y			-			结果将被零填充
		','		-			-			y2				y5			-			结果将包含特定于区域设置的分组分隔符
		'('		-			-			y4				y5			-			结果将用括号括起负数。
		====================================================================================================================================
		1 	取决于Formattable的定义。
		2 	仅针对'd'转换
		3 	仅针对'o'、'x'、和'X'转换。
		4 	对于'd'、'o'、'x'、和'X'转换应用于BigInteger或'd'应用于byte、Byte、short、Short、int 、Integer、long 和 Long。
		5 	仅针对'e'、'E'、'f'、'g' 和 'G'转换。
		未显式定义为标志的任何字符都是非法的，并保留用于将来的扩展。
	
	5、宽度（Width）
		宽度是要写入输出的最小字符数。对于行分隔符转换，宽度不适用；如果提供了宽度，则将引发异常。
	
	6、精密度（Precision）
		对于General参数类型，精度是要写入输出的最大字符数。
		对于floating-point（浮点）转换类型，'a', 'A', 'e', 'E', 和 'f' ，精度是基数点后的小数位数。如果转换为'g'或 'G'，则精度是四舍五入后结果大小中的位数总数。
		对于Character（字符）、Integral（整数）和Date/Time（日期/时间）参数类型以及百分比和行分隔符转换，精度对它们不适用；如果提供精度，则将引发异常。
				
	7、参数索引（Argument Index）	
		参数索引是一个十进制整数，指示参数在参数列表中的位置。第一个参数由“1$”引用，第二个参数由“2$”引用，等等。
		按位置引用参数的另一种方法是使用'<' ('\u003c') 标志，这将导致重新使用上一个格式说明符的参数。例如，以下两个语句将生成相同的字符串：
			Calendar c = ...;
			String s1 = String.format("Duke's Birthday: %1$tm %1$te,%1$tY", c);		
			String s2 = String.format("Duke's Birthday: %1$tm %<te,%<tY", c);
	
二、详情（Details）
	本节旨在提供格式化的行为详细信息，包括条件和异常、支持的数据类型、本地化以及标志、转换和数据类型之间的交互。有关格式化概念的概述，请参阅摘要
	未明确定义为conversions、date/time转换后缀或标志的任何字符都是非法的，并保留用于将来的扩展。在格式字符串中使用此类字符将导致引发UnknownFormatConversionException异常或UnknownFormatFlagsException异常。
	如果格式说明符包含不适用于相应参数的转换字符，则将引发IllegalFormatConversionException异常。
	所有指定的异常都可以由Formatter的任何格式方法以及任何格式convenience方法（如String.format和PrintStream.printf）引发。
	由大写字符（即'B', 'H', 'S', 'C', 'X', 'E', 'G', 'A', 和 'T'）表示的转换与相应小写转换字符的转换相同，但结果根据当前区域设置的规则转换为大写。结果等效于以下对String.toUpperCase()的调用。
		out.toUpperCase() 
	
	1、General（常规类型转换）
		以下常规转换可应用于任何参数类型：
		'b'	'\u0062'	生成Boolean.toString(boolean)返回的“true”或“false”。如果参数为null，则结果为“false”。如果参数是boolean或Boolean值，则结果是String.valueOf()返回的字符串。否则，结果为“true”。
						如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。		
		'B'	'\u0042'	'b'的大写形式。
		'h'	'\u0068'	生成表示对象哈希代码值的字符串。如果参数arg为null，则结果为“null”。否则，通过调用Integer.toHexString(arg.hashCode())获得结果。
						如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。
		'H'	'\u0048'	'h'的大写形式。
		's'	'\u0073'	生产字符串。如果参数为null，则结果为“null”。如果参数实现了Formattable接口，则调用其formatTo方法。否则，将通过调用参数的toString()方法来获得结果。
						如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。
		'S'	'\u0053'	's'的大写形式。
		
		以下标志适用于常规转换：		
		'-'	'\u002d'	左对齐输出。转换值的末尾将根据需要添加空格（“\u0020”），以填充字段的最小宽度。如果未提供宽度，则将引发MissingFormatWidthException。如果未给出此标志，则输出将右对齐。
		'#'	'\u0023'	要求输出使用替代形式。表单的定义由转换指定。
		宽度是要写入输出的最小字符数。如果转换值的长度小于宽度，则输出将被' ' ('\u0020') 填充，直到字符总数等于宽度。默认情况下，填充在左侧。如果给出了“-”标志，则填充将在右侧。如果没有指定宽度，则没有最小值。
		精度是要写入输出的最大字符数。精度在宽度之前应用，因此即使宽度大于精度，输出也将被截断为精度字符。如果未指定精度，则字符数没有显式限制。
	
	2、Character（字符类型转换）
		此转换可应用于char和Character。当Character.isValidCodePoint(int)返回true时，它也可以应用于byte, Byte, short, Short, int 和 Integer类型。如果返回false，则将引发IllegalFormatCodePointException异常。
		'c'	'\u0063'	将参数格式化为Unicode字符，如Unicode字符表示中所述。在参数表示补充字符的情况下，这可能不止一个16位字符。
						如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。		
		'C'	'\u0043'	'c'大写形式。
		'-'标志适用常规转换定义。如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。
		宽度（width）定义适用常规转换。
		精度（precision）不适用。如果指定了精度，则将引发IllegalFormatSprecisionException异常。
	
	3、Numeric（数字类型转换）
		数字转换分为以下类别：
			1、Byte, Short, Integer, and Long
			2、BigInteger
			3、Float and Double
			4、BigDecimal
		数字类型将根据以下算法进行格式化：
		● 数字定位算法
		 在获取整数部分、小数部分和指数（适用于数据类型）的数字后，应用以下转换：
		 	1、字符串中的每个数字字符d都替换为一个特定于区域设置（locale）的数字，该数字是相对于当前区域设置的零位z计算的；即d-'0'+z。
		 	2、如果存在十进制分隔符，则替换特定于区域设置的十进制分隔符
		 	3、如果给定了',' ('\u002c')标志，则通过扫描字符串的整数部分（从最低有效数字到最高有效数字），并按照区域设置（locale）分组大小定义的间隔插入一个特定于区域设置（locale）的分组分隔符，来插入特定于区域设置（locale）的分组分隔符。
			4、如果给定了 '0' 标志，则在符号字符（如果有）之后和第一个非零数字之前插入特定于区域设置（locale）的零位，直到字符串的长度等于请求的字段宽度。
			5、如果该值为负数，并且给出了'('标志，则会在前面加上 '('（'\u0028'），并附加一个')' （'\u0029'）。
			6、如果该值为负（或浮点负零），且未给出'('标志，则会预先准备一个'-' ('\u002d')。
			7、如果给定了'+'标志，并且该值为正或零（或浮点正零），则会预先准备一个 '+' ('\u002b')。
		如果值为NaN或正无穷大，则分别输出文本字符串"NaN"或"Infinity"。如果值为负无穷大，则输出将为"(Infinity)"，如果给定'('标志，否则输出将为"-Infinity"。这些值未本地化。
		
		● Byte, Short, Integer, and Long
		以下转换可适用于byte, Byte, short, Short, int and Integer, long, 和 Long。
		===============================================================================================================================================================
		'd'	'\u0064'	将参数格式化为十进制整数。采用定位算法。如果给定了'0'标志且该值为负数，则零填充将出现在符号之后。如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'o'	'\u006f'	将参数格式化为以8为基数的整数（八进制）。未应用本地化。如果x为负，则结果将是一个无符号的值，该值加上2n，其中n是Byte, Short, Integer, 或Long类对象（视情况而定）中静态SIZE字段返回的类型中的位数。
						如果给出了'#'标志，则输出将始终以基数指示符 '0'开头（八进制前缀）。如果给定了'0'标志，则输出将用前导零填充到任何符号指示后的字段宽度。
						如果给定了'(', '+', '  ', 或 ',' 标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'x'	'\u0078'	将参数格式设置为以16为基数的整数（十六进制）。未应用本地化。如果x为负，则结果将是一个无符号的值，该值加上2n，其中n是Byte, Short, Integer, 或Long类对象（视情况而定）中静态SIZE字段返回的类型中的位数。
						如果给出了'#'标志，则输出将始终以基数指示器'0x'开头。如果给定了'0'标志，则输出将在基数指示器或符号（如果存在）后用前导零填充到字段宽度。
						如果给定了'(', '  ', '+', 或 ',' 标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'X'	'\u0058'	“x”的大写形式。表示数字的整个字符串将被转换为大写，包括'x'（如果有）和所有十六进制数字'a'-'f'（'\u0061'-'\u0066'）。
		
		如果转换为'o', 'x',或 'X'，并且同时给出了'#'和'0'标志，则结果将包含基数指示器（'0'表示八进制，'0x'或'0X'表示十六进制）、一些零（基于宽度）和值。
		如果没有给出'-'标志，则符号前面将出现空格填充。
		
		以下标志适用于整数数值转换：
		===============================================================================================================================================================
		'+'	'\u002b'	要求输出包含所有正数的正符号。如果未给定此标志，则只有负值才会包含符号。如果同时给出'+'和' '标志，则将引发IllegalFormatFlagsException异常。
		
		' '	'\u0020'	要求输出包含一个单独的额外空格('\u0020')用于非负值。如果同时给出'+'和' '标志，则将引发IllegalFormatFlagsException异常。		
		
		'0'	'\u0030'	要求在任何符号或基数指示符之后用前导零填充输出，直至最小字段宽度，转换NaN或infinity（无穷大）时除外。如果未提供宽度，则将引发MissingFormatWidtheException异常。
		
		','	'\u002c'	要求输出包含特定于区域设置（locale）的组分隔符，如本地化算法的"group"部分所述。
		
		'('	'\u0028'	要求输出在负值前加上'(' ('\u0028')并附加一个')' ('\u0029')。
		
		如果没有给定标志，默认格式如下：			
			● 输出在宽度内右对齐。	
			● 负数以'-'开头('\u002d')。
			● 正数和零不包含符号或额外的前导空格。	
			● 不包括分组分隔符。
		宽度是要写入输出的最小字符数。这包括任何符号、数字、分组分隔符、基数指示符和括号。如果转换值的长度小于宽度，则输出将用空格（“\u0020”）填充，直到字符总数等于宽度。默认情况下，填充在左侧。如果给出了“-”标志，则填充将在右侧。如果没有指定宽度，则没有最小值。
		精度（precision）不适用。如果指定了精度，则将引发IllegalFormatSprecisionException异常。
		
		
		● BigInteger
		以下转换可应用于BigInteger。
		===============================================================================================================================================================
		'd'	'\u0064'	要求将输出格式化为十进制整数。采用定位算法。如果给定了'#'标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'o'	'\u006f'	要求将输出格式化为8进制整数。未应用本地化。如果x为负数，则结果将是一个以“-”开头的有符号值（“\u002d”）。此类型允许有符号输出，因为与基元类型不同，在不假定显式数据类型大小的情况下，无法创建无符号等效类型。
						如果x为正或零，并且给出了'+'标志，那么结果将以'+'('\u002b')开头。如果给定了'#'标志，则输出将始终以'0'前缀开头。
						如果给定了'0'标志，则输出将用前导零填充到任何符号指示后的字段宽度。如果给定了',' 标志，则将引发FormatFlagsConversionMismatchException异常。
		'x'	'\u0078'	要求将输出格式化为16十六进制整数。未应用本地化。如果x为负数，则结果将是一个以'-'开头的有符号值（'\u002d'）。此类型允许有符号输出，因为与基元类型不同，在不假定显式数据类型大小的情况下，无法创建无符号等效类型。
						如果x为正或零，并且给出了'+'标志，那么结果将以'+''+'('\u002b')开头。如果给出了'#'标志，则输出将始终以基数指示器'0x'开头。
						如果给定了'0'标志，则输出将在基数指示器或符号（如果存在）后用前导零填充到字段宽度。如果给定了',' 标志，则将引发FormatFlagsConversionMismatchException异常。
						
		'X'	'\u0058'	“x”的大写形式。表示数字的整个字符串将被转换为大写，包括'x'（如果有）和所有十六进制数字'a'-'f'（'\u0061'-'\u0066'）。
		
		如果转换为“o”、“x”或“x”，并且同时给出了“#”和“0”标志，则结果将包含基本指示符（“0”表示八进制，“0x”或“0X”表示十六进制）、一些零（基于宽度）和值。
		如果给定了“0”标志且该值为负数，则零填充将出现在符号之后。
		如果没有给出“-”标志，则符号前面将出现空格填充。
		为Byte, Short, Integer, 和 Long应用定义的所有标志。没有给定标志时的默认行为与Byte, Short, Integer, 和 Long相同。
		宽度的规格与Byte, Short, Integer, 和 Long的定义相同。
		精度（precision）不适用。如果指定了精度，则将引发IllegalFormatSprecisionException异常。
		
		
		● Float and Double
		以下转换可应用于float, Float, double 和 Double。
		===============================================================================================================================================================
		'e'	'\u0065'	要求使用计算机科学记数法格式化输出。采用定位算法。幅度m的格式取决于其值。如果m是NaN或无穷大，则分别输出文本字符串"NaN"或"Infinity"。这些值未本地化。如果m为正零或负零，则指数将为“+00”。否则，结果是一个字符串，它表示参数的符号和大小（绝对值）。符号的格式在本地化算法中进行了描述。幅度m的格式取决于其值。
						设n为唯一整数，使10n<=m<10n+1；然后设a为m和10n的数学精确商，使1<=a<10。然后，将幅度表示为a的整数部分，表示为一个十进制数字，然后是十进制分隔符，然后是表示a的小数部分的十进制数字，然后是指数符号“e”（'\u0065'），然后是指数的符号，最后是表示n为十进制整数的十进制数字，由方法Long.toString(long, int)生成，零填充以包含至少两个数字。
						结果中m或a的小数部分的位数等于精度。如果未指定精度，则默认值为6。如果精度小于Float.toString(float) 或Double.toString(double)返回的字符串中小数点后出现的位数，则使用舍入半向上算法对值进行舍入。否则，可以附加零以达到精度。对于值的规范表示，请根据需要使用Float.toString(float)或Double.toString(double)。
						如果给定了 ','标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'E'	'\u0045'	'e'的大写形式。 指数符号将为'E' ('\u0045')。
		
		'g'	'\u0067'	要求输出的格式为以下所述的一般科学符号。采用定位算法。对精度进行舍入后，生成的幅度m的格式取决于其值。如果m大于或等于10-4但小于10精度，则以十进制格式表示。如果m小于10-4或大于或等于10精度，则用计算机科学记数法表示。
						m中有效位数的总数等于精度。如果未指定精度，则默认值为6。如果精度为0，则取1。如果给定了“#”标志，则将引发FormatFlagsConversionMismatchException异常。
		
		'G'	'\u0047'	'g'的大写形式。
		
		'f'	'\u0066'	要求使用十进制格式格式化输出。采用定位算法。结果是一个字符串，它表示参数的符号和大小（绝对值）。符号的格式在本地化算法中进行了描述。幅度m的格式取决于其值。如果m "NaN"或"Infinity"，将分别输出文本字符串"NaN"或"Infinity"。这些值未本地化。
						幅度的格式为m的整数部分，没有前导零，后面是小数点分隔符，后面是表示m的小数部分的一个或多个十进制数字。结果中m或a的小数部分的位数等于精度。如果未指定精度，则默认值为6。
						如果精度小于Float.toString（float）或Double.toString（double）返回的字符串中小数点后出现的位数，则使用舍入半向上算法对值进行舍入。否则，可以附加零以达到精度。对于值的规范表示，请根据需要使用Float.toString（float）或Double.toString（double）。
		
		'a'	'\u0061'	要求输出以十六进制指数形式格式化。未应用本地化。结果是一个字符串，它表示参数x的符号和大小（绝对值）。如果x为负值或负值，则结果将以'-'('\u002d')开头。如果x为正值或为正值，并给出'+'标志，则结果将以'+' ('\u002b')开头。幅度m的格式取决于其值。
						如果值为"NaN"或"Infinity"，则分别输出文本字符串"NaN"或"Infinity"。如果m为零，则用字符串“0x0.0p0”表示。
						如果m是一个具有规范化表示的double值，则子字符串用于表示有效位和指数字段。有效位由字符"0x1."表示，然后是有效位其余部分的十六进制表示，作为分数。指数由'p' ('\u0070') 和无偏差指数的十进制字符串表示，就好像是通过对指数值调用Integer.toString生成的一样。如果指定了精度，则该值将四舍五入到给定的十六进制数。
						如果m是具有次正规表示的double精度值，则除非指定精度在1到12范围内（包括1到12），否则有效位由字符'0x0.'表示，后跟有效位其余部分的十六进制表示作为分数，指数由'p-1022'表示。如果精度在间隔[1，12]内，则对次正常值进行规格化，使其以字符'0x1.'开头，四舍五入到精度的十六进制位数，并相应调整指数。注意，在次正规有效位中必须至少有一个非零数字。
						如果给定了'(' 或 ',' 标志，则将引发FormatFlagsConversionMismatchException异常。
		'A'	'\u0041'	'a'大写形式。表示数字的整个字符串将转换为大写，包括'x' ('\u0078')和'p' ('\u0070'以及所有十六进制数字'a' - 'f' ('\u0061' - '\u0066')。		
				
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		