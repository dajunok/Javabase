一、案例说明：
二、源代码文件（.java）介绍：
三、知识点：（注：文档中的△符号表示覆盖重写方法。）
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	1、Iterable<T>接口：可迭代接口。故名思议，实现了这个接口的集合对象支持迭代，是可迭代的。它是一个函数式接口。
		
		接口定义：public interface Iterable<T>
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		forEach(Consumer<? super T> action):default void 
			对iterable（指的是实现该接口的集合对象）的每个元素执行给定的操作，直到所有元素都被处理或操作引发异常为止。
		Iterator<T> iterator()
			返回T类型元素的迭代器。	
		spliterator():default Spliterator<T> 
			在这个Iterable描述的元素上创建一个Spliterator迭代器。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	2、Collection<E>接口：容器接口。该接口继承于Iterable<E>，使得java中所有实现Collection<E>的容器类，都能有统一的访问接口。Collection仅仅定义一组保存元素的最基本的操作集合。不包含获取元素和随机访问元素的操作集合，也不包含替换、插入等接口，就连remove、removeAll、retainAll方法都是可选的方法。但是作为持有元素的容器，这体现了接口最小职责的原则，使得大多数具体类型的容器能实现特定操作集合的同时，又能保证容器的通用性。
		
		接口定义：public interface Collection<E> extends Iterable<E>
		所有父接口：Iterable<E>
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
		add(E element):boolean
			将元素e添加到此集合中，如果添加成功则返回true,添加失败则返回false
		addAll(Collection<? extends E> c):boolean
			将指定 collection 中的所有元素都添加到此 collection 中.
		clear():void
			移除此 collection 中的所有元素。
		contains(Object o):boolean
			如果此 collection 包含指定的元素，则返回 true。更确切地讲，当且仅当此 collection 至少包含一个满足 (o==null ? e==null : o.equals(e)) 的元素 e 时，返回 true。
		containsAll(Collection<?> c):boolean
			如果此 collection 包含指定 collection 中的所有元素，则返回 true。
		equals(Object o):boolean
			比较此 collection 与指定对象是否相等
		hashCode():int
				返回此 collection 的哈希码值
		isEmpty():boolean
			如果此 collection 不包含元素，则返回 true,否则返回false
		iterator():Iterator<E>
			返回在此 collection 的元素上进行迭代的迭代器。关于元素返回的顺序没有任何保证（除非此 collection 是某个能提供保证顺序的类实例）。
		parallelStream():Stream<E>
			获取该集合的并行的流。
		remove(Object o):boolean
			从此 collection 中移除指定元素Object的单个实例,如果操作成功则返回true,操作失败则返回false
		removeAll(Collection<?> c):boolean
			移除此 collection 中那些也包含在指定 collection 中的所有元素。
		removeIf(Predicate<? super E> filter):boolean
			删除集合中符合条件的成员，empty集合也可以，但是null就炸啦。通过指定的过滤器来删除元素。
		retainAll(Collection<?> c):boolean
			仅保留此 collection 中那些也包含在指定 c中的元素。
		size():int   
			返回此 collection 中的元素数量。如果此 collection 包含的元素大于 Integer.MAX_VALUE，则返回 Integer.MAX_VALUE。
		spliterator():Spliterator<E>
			主要支持java8中的流式操作，如排序，过滤等，提供类似jquery的语法。
			Spliterator接口是1.8新加的接口，字面意思可分割的迭代器，不同以往的iterator需要顺序迭代，
			Spliterator可以分割为若干个小的迭代器进行并行操作，既可以实现多线程操作提高效率，又可以避免普通迭代器的fail-fast机制所带来的异常。
			Spliterator可以配合1.8新加的Stream进行并行流的实现，大大提高处理效率。
		stream():Stream<E>
			获取该集合的非并行的流。
			Stream 作为 Java 8 的一大亮点，它与 java.io 包里的 InputStream 和 OutputStream 是完全不同的概念。它也不同于 StAX 对 XML 解析的 Stream，
			也不是 Amazon Kinesis 对大数据实时处理的 Stream。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、
			高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda 表达式，
			极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。
			通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。
			所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。
		toArray():Object[]
			返回包含此 collection 中所有元素的数组。如果 collection 对其迭代器返回的元素顺序做出了某些保证，那么此方法必须以相同的顺序返回这些元素。
		toArray(T[] a):T[]
			返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同，也就是说此方法可以指定返回数组中的对象类型
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	3、List<E>接口：列表 【Since:1.2】
		有序集合（也称为序列）。这个接口的用户可以精确控制每个元素在列表中的插入位置。用户可以通过其整数索引（列表中的位置）访问元素，并搜索列表中的元素。
		与集合不同，列表通常允许重复元素。更正式地说，列表通常允许元素e1和e2对，这样e1.equals(e2)，如果它们允许空元素，那么它们通常允许多个空元素。有人可能希望通过在用户尝试插入运行时抛出异常来实现一个禁止重复的列表，这不是不可想象的，但是我们希望这种用法很少出现。
		列表接口在迭代器的iterator, add, remove, equals 和  hashCode方法上放置了除集合接口中指定的以外的其他规定。为了方便起见，这里还包括其他继承方法的声明。
		列表接口提供了四种方法来对列表元素进行位置（索引）访问。列表（如Java数组）是零基（下标以0开始）的。注意，对于某些实现（例如LinkedList类），这些操作可以按照与索引值成比例的时间执行。因此，如果调用者不知道实现，那么迭代列表中的元素通常比，索引它（通过索引查找）要好。
		列表接口提供了一个特殊的迭代器，称为ListIterator迭代器，除了迭代器接口提供的正常操作之外，它还允许元素插入和替换以及双向访问。提供了一种方法来获取从列表中指定位置开始的列表迭代器。
		列表接口提供两种方法来搜索指定的对象。从性能的角度来看，这些方法应该谨慎使用。在许多实现中，它们将执行高代价的线性搜索（速度更快）。
		列表接口提供了两种方法，可以在列表中的任意点高效地插入和删除多个元素。
		注意：虽然允许列表将自己作为元素包含，但建议特别小心：Equals和HashCode方法不再在此类列表中定义良好。
		有些列表实现对可能包含的元素有限制。例如，一些实现禁止空元素，一些实现对其元素的类型有限制。试图添加不合格元素会引发未选中的异常（ unchecked exception），通常为NullPointerException或ClassCastException。试图查询不合格元素的存在可能会引发异常，或者只是返回false；一些实现将显示前一种行为，而一些实现将显示后一种行为。更一般地说，在不合格元素上尝试操作，如果完成操作不会导致不合格元素插入到列表中，可能会引发异常，或者根据实现的选择，可能会成功。此类异常在该接口的规范中标记为“可选”。
		此接口是Java集合框架的成员。
		
		接口定义：public interface List<E> extends Collection<E>
		所有父接口：Collection<E>, Iterable<E>		
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		add(E e):boolean 
			△将指定的元素附加到此列表的末尾（可选操作）。
			支持此操作的列表可能会限制哪些元素可以添加到此列表中。特别是，一些列表将拒绝添加空元素，而其他列表将对可能添加的元素类型施加限制。列表类应该在它们的文档中明确地指定对可以添加哪些元素的任何限制。
			【Throws】：
				● UnsupportedOperationException
					如果此列表不支持添加操作（一般指没有实现功能代码，需要子类自己实现）
				● ClassCastException
					如果指定元素的类阻止将其添加到此列表中
				● NullPointerException
					如果指定的元素为空，并且此列表不允许空元素
				● IllegalArgumentException 
					如果此元素的某些属性阻止将其添加到此列表中
		add(int index, E element):void
			在此列表中的指定位置插入指定元素（可选操作）。将当前位于该位置的元素（如果有的话）和任何后续元素移到右边（向它们的索引中添加一个）。
			【Throws】：
				● UnsupportedOperationException	如果此列表不支持add操作（一般指没有实现功能代码，需要子类自己实现）
				● ClassCastException	如果指定元素的类阻止将其添加到此列表中
				● NullPointerException	如果指定的元素为null，并且此列表不允许null元素
				● IllegalArgumentException 如果此元素的某些属性阻止将其添加到此列表中 
				● IndexOutOfBoundsException	如果索引超出范围(index < 0 || index > size())
		addAll(int index, Collection<? extends E> c):boolean
			将指定集合中的所有元素插入到指定位置的列表中（可选操作）。将当前位于该位置的元素（如果有的话）和任何后续元素向右移动（增加它们的索引）。新元素将以指定集合的迭代器返回的顺序出现在此列表中。如果在操作进行中修改指定的集合，则此操作的行为未定义。（注意，如果指定的集合是这个列表，并且它是非空的，则会发生这种情况。）成功插入所有元素后返回true。
			【Throws】：
				● UnsupportedOperationException	如果此列表不支持addAll操作（一般指没有实现功能代码，需要子类自己实现）
				● ClassCastException	如果指定集合的元素的类阻止将其添加到此列表中
				● NullPointerException	如果指定的集合包含一个或多个null元素，并且此列表不允许null元素，或者指定的集合为null
				● IllegalArgumentException 如果指定集合的某个元素的某些属性阻止将其添加到此列表中
				● IndexOutOfBoundsException	如果索引超出范围(index < 0 || index > size())
		addAll(Collection<? extends E> c):boolean 
			△按指定集合的迭代器返回元素的顺序（可选操作）将指定集合中的所有元素追加到此列表的末尾。如果在操作进行过程中修改了指定的集合，则此操作的行为未定义。（请注意，如果指定的集合是此列表，并且不是空的，则会发生这种情况。）
			【Throws】：
				● UnsupportedOperationException	如果此列表不支持addAll操作（一般指没有实现功能代码，需要子类自己实现）
				● ClassCastException	如果指定集合的元素的类阻止将其添加到此列表中
				● NullPointerException	如果指定的集合包含一个或多个null元素，并且此列表不允许null元素，或者指定的集合为null
				● IllegalArgumentException 如果指定集合的某个元素的某些属性阻止将其添加到此列表中
		clear():void 
			△从此列表中删除所有元素（可选操作）。此调用返回后，列表将为空。
		contains(Object o):boolean 
			△如果此列表包含指定元素，则返回true。更正式地说，如果并且仅当此列表包含至少一个元素(o==null ? e==null : o.equals(e))。
			【Throws】：
				● ClassCastException	如果指定元素的类型与此列表不兼容（可选）
				● NullPointerException	如果指定的元素为null，并且此列表不允许null元素（可选）
		containsAll(Collection<?> c):boolean 
			△如果此列表包含指定集合的所有元素，则返回true。
			【Throws】：
				● ClassCastException	如果指定集合中的一个或多个元素的类型与此列表不兼容（可选）
				● NullPointerException	如果指定的集合包含一个或多个null元素，并且此列表不允许null元素（可选），或者指定的集合为null
		equals(Object o):boolean 
			△将指定的对象与此列表比较是否相等。如果且仅当指定的对象也是列表时，两个列表的大小相同，并且两个列表中所有对应的元素对都相等，则返回true。（两个元素e1和e2相等，如果（e1==null ? e2==null : e1.equals(e2))）换句话说，如果两个列表包含的元素顺序相同，则定义为相等。此定义确保equals方法在列表接口的不同实现中正常工作。
		get(int index):E	
			返回列表中指定位置的元素。
			【Throws】：
				● IndexOutOfBoundsException	如果索引超出范围(index < 0 || index >= size())
		hashCode():int 
			△ 返回此列表的哈希代码值。列表的哈希代码定义为以下计算的结果：
				int hashCode = 1;
			     for (E e : list)
			         hashCode = 31*hashCode + (e==null ? 0 : e.hashCode());
			这样可以确保list1.equals(list2)意味着list1.hashCode()==list2.hashCode()对于任何两个列表list1和list2，都是按照Object.hashCode()的常规约定执行的。
		indexOf(Object o):int
			返回此列表中指定元素的第一个匹配项的索引，如果此列表不包含元素，则返回-1。更正式地说，返回最低的索引i，以便(o==null ? get(i)==null : o.equals(get(i)))，如果没有此类索引，则为-1。
			【Throws】：
				● ClassCastException	如果指定元素的类型与此列表不兼容（可选）
				● NullPointerException	如果指定的元素为null，并且此列表不允许null元素（可选）
		isEmpty():boolean 
			△ 如果此列表不包含元素，则返回true。
		iterator():Iterator<E> 
			△ 以正确的顺序返回此列表中元素的迭代器。
		lastIndexOf(Object o):int
			返回此列表中指定元素的最后一次出现的索引位置，如果该列表不包含指定元素，则返回-1。也就是它会从序列的队尾向队头进行遍历。
			【Throws】：
				● ClassCastException	如果指定元素的类型与此列表不兼容（可选）
				● NullPointerException	如果指定的元素为null，并且此列表不允许null元素（可选）
		listIterator():ListIterator<E>
			返回此列表中的元素的列表迭代器（按适当顺序）。
		listIterator(int index):ListIterator<E>
			从列表中的指定位置开始，返回列表中元素的列表迭代器（按适当顺序）。
		remove(int index):E
			删除列表中指定位置的元素（可选操作）。向左移动任何后续元素（从其索引中减去一个）。返回从列表中删除的元素。
			【Throws】：
				● UnsupportedOperationException 如果此列表不支持删除操作（一般指没有实现功能代码，需要子类自己实现）
				● IndexOutOfBoundsException 如果索引超出范围(index < 0 || index >= size())
		remove(Object o):boolean 
			△ 从该列表中删除指定元素的第一个匹配项（如果存在）（可选操作）。如果此列表不包含元素，则它是不变的。更正式地说，删除索引i最低的元素，这样(o==null ? get(i)==null : o.equals(get(i))) (if such an element exists)（如果存在这样的元素）。如果此列表包含指定元素，则返回“true”（如果此列表因调用而更改，则返回“true”）。
			【Throws】：
				● ClassCastException	如果指定元素的类型与此列表不兼容（可选）
				● NullPointerException 如果指定的元素为空，并且此列表不允许空元素（可选）
				● UnsupportedOperationException 如果此列表不支持remove操作（一般指没有实现功能代码，需要子类自己实现）
		removeAll(Collection<?> c):boolean 
			△ 从此列表中删除指定集合中包含的所有元素（可选操作）。如果此列表因调用而更改，则为true
			【Throws】：
				● UnsupportedOperationException 如果此列表不支持removeAll操作
				● ClassCastException	如果此列表的元素的类与指定的集合不兼容（可选）
				● NullPointerException 如果此列表包含null元素，并且指定的集合不允许null元素（可选），或者指定的集合为null				
		replaceAll(UnaryOperator<E> operator):default void
			将此列表中的每个元素替换为将operator应用于该元素的结果。由operator引发的错误或运行时异常将中继（断言）到调用方。
			对于此列表，默认实现等效于：
					final ListIterator<E> li = list.listIterator();
			     	while (li.hasNext()) {li.set(operator.apply(li.next()));}	
			如果列表的列表迭代器不支持set操作（set方法），则在替换第一个元素时将引发UnsupportedOperationException异常。
			【Throws】：
				● UnsupportedOperationException 如果这列表是不可更改的。如果元素不可以被替换，一般指不支持修改，该实现将抛出此异常。
				● NullPointerException 如果指定的operator为null，或者operator操作结果值为null，并且此列表不允许null元素（可选）				
		retainAll(Collection<?> c):boolean 
			△仅保留此列表中包含在指定集合中的元素（可选操作）。换句话说，从该列表中删除不包含在指定集合中的所有元素。如果此列表因调用而更改，则为true
			【Throws】：
				● UnsupportedOperationException 如果此列表不支持retainAll操作（一般指没有实现功能代码，需要子类自己实现）
				● ClassCastException	如果此列表的元素的类与指定的集合不兼容（可选）
				● NullPointerException 如果此列表包含null元素，并且指定的集合不允许null元素（可选），或者指定的集合为null	
		set(int index, E element):E
			用指定的元素替换列表中指定位置的元素（可选操作）。返回以前位于指定位置的元素（返回旧元素）
			【Throws】：
				● UnsupportedOperationException	如果此列表不支持set操作（一般指没有实现功能代码，需要子类自己实现）
				● ClassCastException	如果指定元素的类阻止将其添加到此列表中
				● NullPointerException	如果指定的元素为null，并且此列表不允许null元素
				● IllegalArgumentException 如果此元素的某些属性阻止将其添加到此列表中 
				● IndexOutOfBoundsException	如果索引超出范围(index < 0 || index >= size())
		size():int 
			△ 返回此列表中的元素数量。如果此列表包含的元素超过Integer.MAX_VALUE，则返回Integer.MAX_VALUE。
		sort(Comparator<? super E> c):default void
			根据c指定的比较规则（比较器）对容器元素进行排序。
			此列表中的所有元素都必须使用指定的比较器进行相互比较（即，c.compare(e1, e2)不能对列表中的任何元素e1和e2抛出ClassCastException异常）。
			如果指定的comparator为空，那么列表中的所有元素都必须实现Comparable接口，并且应该使用元素的自然顺序。
			此列表必须可修改，但不必调整大小。
			默认实现获取包含此列表中所有元素的数组，对数组进行排序，并在此列表上迭代，从数组中的相应位置重置每个元素。（这避免了尝试在适当位置对链接列表排序所导致的n2 log(n)性能。）
			这个实现是一个稳定的、自适应的、迭代的合并排序，当输入数组部分排序时，需要的比较远少于n lg（n），而当输入数组随机排序时，提供传统合并排序的性能。如果输入数组接近排序，则实现需要大约n个比较。临时存储需求从几乎排序的输入数组的小常量到随机排序的输入数组的n/2对象引用不等。
			该实现在其输入数组中充分利用了升序和降序的同等优势，并且可以利用同一输入数组不同部分的升序和降序。它非常适合合并两个或更多排序的数组：只需连接数组并对结果数组进行排序。
			【Throws】：
				● ClassCastException 如果列表包含使用指定的比较器不能相互比较的元素
				● UnsupportedOperationException 如果列表的列表迭代器不支持set操作（一般指没有实现功能代码，需要子类自己实现）
				● IllegalArgumentException 如果发现比较器违反比较器契约
		spliterator():default Spliterator<E> 
			△ 在此列表中的元素上创建Spliterator。
			spliterator报告Spliterator.SIZED和Spliterator.ORDERED。实现应该记录额外特征值的报告。
			默认实现从列表的迭代器创建一个后期绑定spliterator。spliterator继承列表迭代器的 fail-fast属性。
			创建的Spliterator还报告Spliterator.SUBSIZED。			
		subList(int fromIndex, int toIndex):List<E>
			返回指定的fromIndex（含）和toIndex（含）之间此列表部分的视图。（如果fromindex和toindex相等，则返回的列表为空。）返回的列表由此列表支持，因此返回列表中的非结构更改将反映在此列表中，反之亦然。返回的列表支持此列表支持的所有可选列表操作。
			这种方法不需要显式的范围操作（数组通常存在的类型）。任何需要列表的操作都可以通过传递子列表视图而不是整个列表来用作范围操作。例如，以下习惯用法从列表中删除一系列元素：
				list.subList(from, to).clear();
			可以为indexOf和lastIndexOf构造类似的习语，Collections类中的所有算法都可以应用于子列表。
			如果支持列表（即此列表）在结构上进行了除通过返回列表以外的任何方式的修改，则此方法返回的列表的语义将变为未定义的。（结构修改是指那些改变列表大小的修改，或者以某种方式干扰列表，使正在进行的迭代可能产生不正确的结果。）
			【Throws】：
				● IndexOutOfBoundsException	对于非法的端点索引值(fromIndex < 0 || toIndex > size || fromIndex > toIndex)
		toArray():Object[] 
			△ 返回一个数组，该数组按正确的顺序（从第一个元素到最后一个元素）包含此列表中的所有元素。
			返回的数组将是“安全的”，因为此列表不维护对它的引用。（换句话说，此方法必须分配一个新数组，即使此列表由数组支持）。因此，调用者可以自由修改返回的数组。
			此方法充当基于数组和基于集合的API之间的桥梁。
		toArray(T[] a):<T> T[] 
			△ 返回一个数组，该数组按正确的顺序（从第一个元素到最后一个元素）包含此列表中的所有元素；返回的数组的运行时类型是指定数组的运行时类型。如果列表符合指定的数组，则将在其中返回。否则，将为新数组分配指定数组的运行时类型和此列表的大小。
			如果列表适合具有备用空间的指定数组（即数组中的元素多于列表中的元素），则紧跟列表末尾的数组中的元素将设置为空。（只有当调用者知道列表不包含任何空元素时，这对于确定列表的长度很有用。）
			与toArray()方法一样，此方法充当基于数组和基于集合的API之间的桥梁。此外，此方法允许对输出数组的运行时类型进行精确控制，并且可以在某些情况下用于节省分配成本。
			假设x是一个已知仅包含字符串的列表。以下代码可用于将列表转储到新分配的字符串数组中：
				String[] y = x.toArray(new String[0]);
			请注意，toArray(new Object[0])功能与toArray()相同
			【Throws】：
				● ArrayStoreException 如果指定数组的运行时类型不是此列表中每个元素的运行时类型的父类型
				● NullPointerException 如果指定的数组为null
				
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	4、Queue<E>接口：队列 【Since:1.5】
		为在处理前保存元素而设计的集合。除了基本的Collection操作之外，队列还提供额外的插入、提取和检查操作。这些方法有两种形式：一种在操作失败时引发异常，另一种返回特殊值（根据操作的不同，为null或为false）。后一种形式的插入操作专门设计用于容量受限的队列实现；在大多数实现中，插入操作不会失败。
					抛出异常				返回特殊值
			插入		add(e)				offer(e)
			删除		remove()			poll()
			提取		element()			peek()	
		Queue通常（但不一定）以先进先出FIFO（first-in-first-out）的方式对元素排序。其中的例外是优先级队列，它根据提供的比较器对元素排序，或元素的自然排序，以及对元素LIFO（后进先出）排序的LIFO队列（或堆栈）。无论使用什么顺序，队列的头部都是通过调用remove()或poll()删除的元素。在FIFO队列中，所有新元素都插入到队列的尾部。其他类型的队列可能使用不同的放置规则。每个队列实现都必须指定其排序属性。
		如果可能，offer方法插入一个元素，失败返回false。这与Collection.add方法不同，后者只能通过引发未检查的异常（unchecked exception）来添加元素。offer方法设计用于当故障是正常情况而非异常情况时使用，例如，在固定容量（或“限定”）队列中。
		remove()和poll()方法删除并返回队列的头部。从队列中准确地删除哪个元素是队列排序策略的一个函数，它的实现与实现不同。remove()和poll()方法仅在队列为空时的行为不同：remove()方法引发异常，poll()方法返回null。
		element()和peek()方法返回但不移除队列的头部。
		Queue接口没有定义阻塞队列方法，这在并发编程中很常见。这些方法等待元素出现或等待空间可用，在扩展此接口的BlockingQueue（阻塞队列）接口中定义。
		Queue实现通常不允许插入空元素，尽管某些实现（如LinkedList）不禁止插入null元素。即使在允许它的实现中，也不应将null插入队列，因为poll方法还将null用作特殊的返回值，以指示队列不包含任何元素。
		队列实现通常不定义方法equals和hashCode的基于元素的版本，而是从类Object继承基于标识的版本，因为对于具有相同元素但顺序属性不同的队列，并不总是定义了基于元素的相等性。
		此接口是Java集合框架的成员。		
		
		接口定义：public interface Queue<E> extends Collection<E>
		父接口：Collection<E>, Iterable<E>
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		add(E e):boolean 
			△ 如果可以在不违反容量限制的情况下立即将指定元素插入此队列，成功时返回true，如果当前没有可用空间，则抛出IllegalStateException。
			【Throws】：
				● IllegalStateException 如果由于容量限制，此时无法添加元素
				● ClassCastException  如果指定元素的类阻止将其添加到此队列中
				● NullPointerException 如果指定的元素为null，并且此队列不允许null元素
				● IllegalArgumentException 如果此元素的某些属性阻止将其添加到此队列
		element():E
			在队列的头部查询并返回元素。如果队列为空时，抛出一个异常。
			【Throws】：
				● NoSuchElementException 如果此队列为空
		offer(E e):boolean
			 如果可以在不违反容量限制的情况下立即将指定元素插入此队列。当使用容量受限队列时，此方法通常比add(E)更可取，因为插入元素失败时候add(E)只能抛出异常。
			【Throws】：
				● ClassCastException  如果指定元素的类阻止将其添加到此队列中
				● NullPointerException 如果指定的元素为null，并且此队列不允许null元素
				● IllegalArgumentException 如果此元素的某些属性阻止将其添加到此
		peek():E
			在队列的头部查询并返回元素。如果队列为空时，返回null。
		poll():E
			检索但不删除此队列的头；如果此队列为空，则返回空值。
		remove():E	
			检索并删除此队列的头。此方法与Poll的不同之处在于，如果此队列为空，它将引发异常。
			【Throws】：
				● NoSuchElementException 如果此队列为空
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	5、Deque<E>接口：双端队列。【Since:1.6】
		支持元素在两端插入和删除的线性集合。deque是"double ended queue"（双端队列）的缩写，通常发音为“deck”。大多数Deque实现，对它们可能包含的元素数量没有固定的限制，但是这个接口支持容量受限的deque以及没有固定大小限制的deque。
		这个接口定义了访问deque两端元素的方法。提供了插入、移除和检查元素的方法。这些方法有两种形式：一种在操作失败时引发异常，另一种返回特殊值（根据操作的不同，为null或为false）。后一种形式的插入操作是专门为容量受限的deque实现而设计的；在大多数实现中，插入操作不会失败。
		下表总结了上述12种方法：
				First Element (Head)			Last Element (Tail)
					抛出异常			特殊值			抛出异常			特殊值
			插入	 addFirst(e)	offerFirst(e)	addLast(e)		offerLast(e)
			移除	 removeFirst()	pollFirst()		removeLast()	pollLast()
			提取	 getFirst()		peekFirst()		getLast()		peekLast()
		此接口扩展Queue接口。当DEQUE用作队列时，将产生FIFO（先进先出）行为。元素被添加到deque的末尾，并从开头移除。从队列接口继承的方法与下表所示的Deque方法完全等效：
			【Queue】方法		等效 【Deque】方法
			add(e)			addLast(e)
			offer(e)		offerLast(e)
			remove()		removeFirst()
			poll()			pollFirst()
			element()		getFirst()
			peek()			peekFirst()		
		Deques也可以用作后进先出LIFO (Last-In-First-Out)栈。这个接口应该优先使用旧的Stack类。当deque用作栈时，元素从deque开始被推送和弹出。Stack方法与下表所示的Deque方法完全相同：
			【Stack】方法		等效 【Deque】方法
			push(e)			addFirst(e)
			pop()			removeFirst()
			peek()			peekFirst()	
		请注意，当deque用作队列或栈时，peek方法也同样有效；在这两种情况下，元素都是从deque开始绘制的。
		此接口提供两种方法来删除内部元素：removeFirstOccurrence和removeLastOccurrence。
		与列表接口不同，此接口不支持对元素的索引访问。
		虽然Deque实现并不严格要求禁止插入null元素，但强烈建议这样做。强烈建议任何允许null元素的Deque实现的用户不要利用插入null元素的能力。这是因为通过各种方法将null值用作特殊返回值，以指示Deque为空。
		deque实现通常不定义equals和hashCode方法的基于元素的版本，而是从类Object继承基于标识的版本。
		此接口是Java集合框架的成员。
	
		接口定义：public interface Deque<E> extends Queue<E>
		父接口：Queue<E>,Collection<E>, Iterable<E>
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		add(E e):boolean 
			△ 如果可以在不违反容量限制的情况下立即执行此操作，则将指定的元素插入此deque表示的队列（换句话说，在该deque的尾部），成功时返回true，如果当前没有可用空间，则抛出IllegalStateException。当使用容量受限的deque时，通常最好使用offer。
			此方法等价于addLast(E)
			【Throws】：
				● IllegalStateException 如果由于容量限制，此时无法添加元素
				● ClassCastException 如果指定元素的类阻止将其添加到此deque（双端队列）中
				● NullPointerException 如果指定的元素为null，并且此deque（双端队列）不允许null元素
				● IllegalArgumentException 如果指定元素的某些属性阻止将其添加到此deque（双端队列）中
		addFirst(E e):void 
			如果可以在不违反容量限制的情况下立即插入指定元素，则在该deque的前面插入该元素；如果当前没有可用空间，则抛出IllegalStateException。当使用容量受限的deque时，通常最好使用offerFirst(E)方法。
			【Throws】：
				● IllegalStateException 如果由于容量限制，此时无法添加元素
				● ClassCastException 如果指定元素的类阻止将其添加到此deque（双端队列）中
				● NullPointerException 如果指定的元素为null，并且此deque（双端队列）不允许null元素
				● IllegalArgumentException 如果指定元素的某些属性阻止将其添加到此deque（双端队列）中
		addLast(E e):void 
			如果可以在不违反容量限制的情况下立即插入指定元素，则在该deque的结尾插入该元素；如果当前没有可用空间，则引发IllegalStateException。当使用容量受限的deque时，通常最好使用offerLast(E)方法。
			此方法相当于add(E)
			【Throws】：
				● IllegalStateException 如果由于容量限制，此时无法添加元素
				● ClassCastException 如果指定元素的类阻止将其添加到此deque（双端队列）中
				● NullPointerException 如果指定的元素为null，并且此deque（双端队列）不允许null元素
				● IllegalArgumentException 如果指定元素的某些属性阻止将其添加到此deque（双端队列）中
		contains(Object o):boolean 
			△ 如果此双端队列包含指定元素，则返回true。更正式地说，如果且仅当此deque包含至少一个元素e（例如(o==null ? e==null : o.equals(e))）时返回true。
			【Throws】：
				● ClassCastException 如果指定元素的类型与此deque（双端队列）不兼容（可选）
				● NullPointerException 如果指定的元素为null，并且此deque（双端队列）不允许null元素
		descendingIterator():Iterator<E> 
			以相反的顺序返回此deque中元素的迭代器（降序迭代器）。元素将按从最后（尾）到第一（头）的顺序返回。
		element():E 
			△ 检索但不删除由这个deque表示的队列的头（换句话说，这个deque的第一个元素）。此方法与peek的不同之处在于，如果此deque为null，它将抛出异常。
			【Throws】：
				● NoSuchElementException 如果deque（双端队列）为空
		getFirst():E 
			检索但不删除此deque的第一个元素。此方法与peekFirst的不同之处在于，如果此deque（双端队列）为空，它将引发异常。
			【Throws】：
				● NoSuchElementException 如果deque（双端队列）为空
		getLast():E 
			检索但不删除此deque的最后一个元素。此方法与peekLast的不同之处在于，如果此deque（双端队列）为空，它将引发异常。
			【Throws】：
				● NoSuchElementException 如果deque（双端队列）为空
		iterator():Iterator<E> 
			△ 返回 以正确的顺序迭代此deque中元素的迭代器。元素将按从第一个（头）到最后一个（尾）的顺序返回。
		offer(E e):boolean 
			△ 如果可以在不违反容量限制的情况下立即执行此操作，则将指定元素插入此deque表示的队列（换句话说，在该deque（双端队列）的尾部），成功时返回true，如果当前没有可用空间，则返回false。当使用容量受限的deque时，此方法通常优于add(E)方法，后者只能通过引发异常而无法插入元素。		
			【Throws】：
				● ClassCastException 如果指定元素的类阻止将其添加到此deque（双端队列）中
				● NullPointerException 如果指定的元素为null，并且此deque（双端队列）不允许null元素
				● IllegalArgumentException 如果指定元素的某些属性阻止将其添加到此deque（双端队列）中
		offerFirst(E e):boolean
			在这个deque（双端队列）的前面插入指定的元素，除非它违反了容量限制。如果将元素添加到此deque，则为true，否则为false。当使用容量受限的deque时，此方法通常优于addFirst(E)方法，后者只能通过引发异常而无法插入元素。
			【Throws】：
				● ClassCastException 如果指定元素的类阻止将其添加到此deque（双端队列）中
				● NullPointerException 如果指定的元素为null，并且此deque（双端队列）不允许null元素
				● IllegalArgumentException 如果指定元素的某些属性阻止将其添加到此deque（双端队列）中
		offerLast(E e):boolean 
			在这个deque的末尾插入指定的元素，除非它会违反容量限制。如果将元素添加到此deque，则为true，否则为false。当使用容量受限的deque时，此方法通常优于addlast（e）方法，后者只能通过引发异常来插入元素。
			【Throws】：
				● ClassCastException 如果指定元素的类阻止将其添加到此deque（双端队列）中
				● NullPointerException 如果指定的元素为null，并且此deque（双端队列）不允许null元素
				● IllegalArgumentException 如果指定元素的某些属性阻止将其添加到此deque（双端队列）中
		peek():E 
			△ 检索但不删除由此deque表示的队列头（换句话说，此deque的第一个元素），或者如果此deque为null，则返回null。
			此方法等效于peekFirst()
			【Throws】：
				● NoSuchElementException 如果deque（双端队列）为空
		peekFirst():E 
			检索但不移除此deque的第一个元素，或者如果此deque为空则返回null。
		peekLast():E 
			检索但不移除此deque的最后一个元素，或者如果此deque为空则返回null。
		poll():E 
			△ 检索并删除由该deque表示的队列的头（换句话说，是该deque的第一个元素），或者如果该deque为空，则返回null。
			此方法等效于pollFirst()
		pollFirst():E 
			检索并删除此deque的第一个元素，如果此deque为空，则返回null。
		pollLast():E 
			检索并删除此deque（双端队列）的最后一个元素，如果此deque为空，则返回null。
		pop():E 
			从此deque（双端队列）所表示的栈中弹出一个元素。换句话说，删除并返回此deque的第一个元素。
			此方法等效于removeFirst()。
		push(E e):void 
			如果可以在不违反容量限制的情况下立即将元素推送到该deque表示的栈上（换句话说，在该deque的头部），如果当前没有可用空间，则引发IllegalStateException异常。
			此方法等效于addFirst(E)
			【Throws】：
				● IllegalStateException 如果由于容量限制，此时无法添加元素
				● ClassCastException 如果指定元素的类阻止将其添加到此deque（双端队列）中
				● NullPointerException 如果指定的元素为null，并且此deque（双端队列）不允许null元素
				● IllegalArgumentException 如果指定元素的某些属性阻止将其添加到此deque（双端队列）中
		remove():E 
			△ 检索并删除由这个deque表示的队列的头（换句话说，这个deque的第一个元素）。此方法与poll的不同之处在于，如果此deque为空，它将引发异常。
			此方法等效于 removeFirst()
			【Throws】：
				● NoSuchElementException 如果deque（双端队列）为空
		remove(Object o):boolean 
			△从该deque中删除指定元素的第一个匹配项。如果deque不包含元素，则它是不变的。更正式地说，删除第一个元素e像这样 (o==null ? e==null : o.equals(e))（如果存在这样的元素）。如果此deque包含指定元素（或等效地，如果此deque由于调用而更改），则返回true。
			此方法等效于removeFirstOccurrence(Object)
		removeFirst():E 
			检索并删除此deque的第一个元素。此方法与pollFirst的不同之处在于，如果此deque为空，它将引发异常。
			【Throws】：
				● NoSuchElementException 如果deque（双端队列）为空		
		removeLast():E 
			检索并删除此deque的最后一个元素。此方法与pollLast的不同之处在于，如果此deque为空，它将引发异常。
			【Throws】：
				● NoSuchElementException 如果deque（双端队列）为空
		removeFirstOccurrence(Object o):boolean
			从该deque中删除指定元素的第一个匹配项。如果deque不包含元素，则它是不变的。更正式地说，删除第一个元素e像这样(o==null ? e==null : o.equals(e))（如果存在这样的元素）。如果此deque包含指定元素（或等效地，如果此deque由于调用而更改），则返回true。
			【Throws】：
				● ClassCastException 如果指定元素的类型与此deque（双端队列）不兼容（可选）
				● NullPointerException 如果指定的元素为null，并且此deque（双端队列）不允许null元素
		removeLastOccurrence(Object o):boolean 
			从该deque中删除指定元素的最后一次出现。如果deque不包含元素，则它是不变的。更正式地说，删除最后一个元素e像这样(o==null ? e==null : o.equals(e))（如果存在这样的元素）。如果此deque包含指定元素（或等效地，如果此deque由于调用而更改），则返回true。
			【Throws】：
				● ClassCastException 如果指定元素的类型与此deque（双端队列）不兼容（可选）
				● NullPointerException 如果指定的元素为null，并且此deque（双端队列）不允许null元素
		size():int 
			△ 返回此deque（双端队列）中的元素数量。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	6、Set<E>接口：数学抽象集合，【Since:1.2】
		不包含重复元素的集合。更正式地说，集合不包含像e1.equals(e2)这样的一对元素e1和e2，并且最多包含一个null元素。正如其名称所暗示的那样，这个接口为数学集抽象建模。
		除了从Collection接口继承的约定之外，Set接口还对所有构造函数的约定以及add、equals和hashCode方法的约定进行了附加规定。为了方便起见，这里还包括其他继承方法的声明。（这些声明随附的规范是为Set接口定制的，但不包含任何附加规定。）
		对构造器的附加规定不足为奇，所有构造器必须创建一个不包含重复元素的集合（如上所定义）
		注意：如果可变对象用作集合元素，则必须非常小心。如果在对象是集合中的元素时，以影响相等比较的方式更改对象的值，则不会指定集合的行为。这种禁止的一个特殊情况是，不允许一个集合作为一个元素来包含它自己。
		一些集合实现对它们可能包含的元素有限制。例如，一些实现禁止空元素，一些实现对其元素的类型有限制。试图添加不合格元素会引发未选中的异常，通常为NullPointerException或ClassCastException。试图查询不合格元素的存在可能会引发异常，或者只是返回false；一些实现将显示前一种行为，而一些实现将显示后一种行为。更一般地说，在不合格元素上尝试操作，如果完成操作不会导致不合格元素插入到集合中，则可能会引发异常，或者根据实现的选择，可能会成功。此类异常在该接口的规范中标记为“可选”。
		此接口是Java集合框架的成员。
		
		
		接口定义：public interface Set<E> extends Collection<E>
		父接口：Collection<E>, Iterable<E>
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
		add(E e):boolean 
			△ 如果指定的元素还不存在，则将其添加到此集合中（可选操作）。更正式地说，如果像这样(e==null ? e2==null : e.equals(e2))，集合不包含元素e2，则将指定的元素e添加到此集合中。如果此集合已经包含元素，则调用将使集合保持不变并返回false。结合对构造函数的限制，这可以确保集合从不包含重复的元素。
			上述规定并不意味着集合必须接受所有元素；集合可以拒绝添加任何特定元素，包括null元素，并抛出异常，如Collection.add规范中所述。单独的集合实现应该清楚地记录对它们可能包含的元素的任何限制。
			【Throws】：
				● IllegalStateException 如果此set不支持add操作
				● ClassCastException 如果指定元素的类阻止将其添加到此set（集合）中
				● NullPointerException 如果指定的元素为null，并且此set（集合）不允许null元素
				● IllegalArgumentException 如果指定元素的某些属性阻止将其添加到此set（集合）中	
		addAll(Collection<? extends E> c):boolean 
			△ 如果指定集合中的所有元素尚不存在，则将它们添加到此集合中（可选操作）。如果指定的c也是一个集合，则addAll操作将有效地修改此集合，使其值为两个集合的并集。如果在操作进行过程中修改了指定的集合，则此操作的行为未定义。
			【Throws】：
				● IllegalStateException 如果此set不支持addAll操作
				● ClassCastException 如果指定集合的元素的类阻止将其添加到此set（集合）中
				● NullPointerException 如果指定的元素为null，并且此set（集合）不允许null元素
				● IllegalArgumentException 如果指定的集合包含一个或多个空元素，并且此集合不允许null元素，或者指定的集合为null	
		clear():void 
			△从该集合中移除所有元素（可选操作）。此调用返回后，集合将为空。
		contains(Object o):boolean 
			△如果此集合包含指定元素，则返回true。更正式地说，如果且仅当此集合包含元素e(o==null ? e==null : o.equals(e))。
			【Throws】：
				● ClassCastException 如果指定元素的类型与此集合不兼容（可选）
				● NullPointerException 如果指定的元素为null，并且此集合不允许null元素（可选）
		containsAll(Collection<?> c):boolean 
			△如果此集合包含指定集合的所有元素，则返回true。如果指定的collection也是集合，则如果该集合是集合的子集，则此方法返回true。		
			【Throws】：
				● ClassCastException 如果指定集合中一个或多个元素的类型与此集合不兼容（可选）
				● NullPointerException 如果指定的集合包含一个或多个null元素，并且此集合不允许null元素（可选），或者指定的集合为null	
		equals(Object o):boolean 
			△ 将指定的对象与此集进行相等比较。如果指定的对象也是一个集合，两个集合的大小相同，并且指定集合的每个成员都包含在此集合中（或等效地，此集合的每个成员都包含在指定集合中），则返回true。此定义确保equals方法在Set接口的不同实现中正常工作。
		hashCode():int 
			△返回此集的哈希代码值。集合的哈希代码定义为集合中元素的哈希代码之和，其中空元素的哈希代码定义为零。这确保s1.equals(s2)意味着s1.hashCode()==s2.hashCode()对于任意两个集合s1和s2，这是Object.hashCode()的一般约定所要求的。	
		isEmpty():boolean 
			△如果此集合不包含元素，则返回true
		iterator():Iterator<E> 
			△ 返回此集合中元素的迭代器。元素不会以特定的顺序返回（除非此集合是某个提供保证的类的实例）。
		remove(Object o):boolean 
			△ 如果指定元素存在，则从该集合中移除该元素（可选操作）。更正式地说，删除像这样(o==null ? e==null : o.equals(e))的元素e，如果这个集合包含这样一个元素，则返回“真”（如果此集合因调用而更改，则返回等效）。（调用返回后，此集合将不包含此元素。）
			【Throws】：
				● UnsupportedOperationException 如果此集合不支持删除操作(一般指未实行功能代码，需子类覆盖实现)
				● ClassCastException 如果指定元素的类型与此集合不兼容（可选）
				● NullPointerException 如果指定的元素为null，并且此集合不允许为null元素（可选）				
		removeAll(Collection<?> c):boolean 
			△ 从此集合中删除包含在指定集合中的所有元素（可选操作）。如果指定的集合也是集合，则此操作将有效地修改此集合，使其值为两个集合的不对称集合差。
			【Throws】：
				● UnsupportedOperationException 如果此集合不支持removeAll操作(一般指未实行功能代码，需子类覆盖实现)
				● ClassCastException 如果指定元素的类型与此集合不兼容（可选）
				● NullPointerException 如果此集合包含null元素，并且指定的集合不允许null元素（可选），或者指定的集合为null
		retainAll(Collection<?> c):boolean 
			△ 仅保留此集合中包含在指定集合中的元素（可选操作）。换句话说，从该集合中删除指定集合中不包含的所有元素。如果指定的集合也是一个集合，则此操作将有效地修改此集合，使其值为两个集合的交集。
			【Throws】：
				● UnsupportedOperationException 如果此集合不支持retainAll操作(一般指未实行功能代码，需子类覆盖实现)
				● ClassCastException 如果此集合的元素的类与指定集合不兼容（可选）
				● NullPointerException 如果此集合包含null元素，并且指定的集合不允许null元素（可选），或者指定的集合为null
		size():int 
			△ 返回此集合中的元素数量（其基数）。如果此集合包含超过Integer.MAX_VALUE元素，则返回Integer.MAX_VALUE。
		spliterator():default Spliterator<E> 
			△ 在此集合中的元素上创建Spliterator（拆分器）。
			Spliterator报告Spliterator.DISTINCT。实现应该记录额外特征值的报告。
			默认实现从集合的迭代器创建后期绑定Spliterator（拆分器）。Spliterator（拆分器）继承集合迭代器的fail-fast属性。	
			创建的Spliterator还报告Spliterator.SIZED
		toArray():Object[] 
			△ 返回包含此集合中所有元素的数组。如果这个集合对迭代器返回元素的顺序有任何保证，那么这个方法必须以相同的顺序返回元素。
			返回的数组将是“安全的”，因为此集合不维护对它的引用。（换句话说，此方法必须分配一个新数组，即使此集合由数组支持）。因此，调用者可以自由修改返回的数组
			此方法充当基于数组和基于集合的API之间的桥梁。
		toArray(T[] a):<T> T[] 
			△ 返回包含此集合中所有元素的数组；返回的数组的运行时类型是指定数组的运行时类型。如果集合符合指定的数组，则将在其中返回该集合。否则，将为新数组分配指定数组的运行时类型和该集合的大小。
			如果此集合适合具有备用空间的指定数组（即，数组中的元素多于此集合），则紧跟集合末尾的数组中的元素将设置为null。（只有当调用者知道该集合不包含任何null元素时，才有助于确定该集合的长度。）
			如果这个集合对迭代器返回元素的顺序有任何保证，那么这个方法必须以相同的顺序返回元素。
			与toarray()方法一样，此方法充当基于数组和基于集合的API之间的桥梁。此外，此方法允许对输出数组的运行时类型进行精确控制，并且可以在某些情况下用于节省分配成本。
			假设x是一个已知仅包含字符串的集合。以下代码可用于将集合转储到新分配的字符串数组中：
				String[] y = x.toArray(new String[0]);
			请注意，toArray(new Object[0])，功能与toarray()相同。
			【Throws】：
				● ArrayStoreException 如果指定数组的运行时类型不是此集合中每个元素的运行时类型的父类型
				● NullPointerException 如果指定的数组为null
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	7、SortedSet<E>接口：提供对其元素的进行排序的集合。保证迭代器按照元素递增顺序遍历的集合，可以按照元素的自然顺序（参见 Comparable）进行排序，
					或者按照创建有序集合时提供的 Comparator进行排序。要采用此排序，还要提供一些其他操作（此接口是 SortedMap 的集合对应物）。 
					插入有序集合的所有元素都必须实现 Comparable 接口（或者被指定的 Comparator 所接受）。另外，所有这些元素都必须是可相互比较的：
					e1.compareTo(e2)（或 comparator.compare(e1, e2)）对于有序集合中的任意元素 e1 和 e2 都不能抛出 ClassCastException。
					试图违反这些限制将导致违反规则的方法或者构造方法调用抛出 ClassCastException。
		父接口：Set<E>,Collection<E>, Iterable<E>		
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		comparator():Comparator<? super E>
			返回用于对集合中的元素进行排序的比较器。
		first():E 
			返回该集合中当前第一个（最低）元素。
		last():E 
			返回当前集合中最后一个元素。
		headSet(E toElement):SortedSet<E> 
			返回从开始到指定元素范围的新集合。		
		tailSet(E fromElement):SortedSet<E> 
			返回从指定元素到最后范围之间的所有元素的新集合。
		subSet(E fromElement, E toElement):SortedSet<E> 
			返回从指定fromElement到toElement范围之间所有元素的新集合（不包含toElement元素）。	
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	8、NavigableSet<E>接口：导航集合。该接口扩展了 SortedSet，具有了为给定搜索目标报告最接近匹配项的导航方法。方法 lower、floor、ceiling 和 higher 分别返回小于、小于等于、大于等于、大于给定元素的元素，如果不存在这样的元素，则返回 null。
		父接口：SortedSet<E>,Set<E>,Collection<E>, Iterable<E>
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		ceiling(E e):E
			返回此 集合中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。
		descendingIterator():Iterator<E> 
			 以降序返回在此集合的元素上进行迭代的迭代器。
		descendingSet():NavigableSet<E> 
			返回此 集合中所包含元素的逆序元素视图。
		floor(E e):E 
			 返回此集合中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。
		headSet(E toElement, boolean inclusive):NavigableSet<E> 
			 返回此集合的部分元素视图，其元素小于（或等于，如果 inclusive 为 true）toElement。
		higher(E e):E 
			返回此集合中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。
		lower(E e):E 
			返回此集合中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。
		pollFirst():E 
			获取并移除第一个（最低）元素；如果此集合为空，则返回 null。
		pollLast():E 
			获取并移除最后一个（最高）元素；如果此 集合为空，则返回 null。
		subSet(E fromElement, boolean fromInclusive,E toElement,  boolean toInclusive):NavigableSet<E> 
			返回此集合的部分元素视图，其元素范围从 fromElement 到 toElement。注意，布尔值表示是否包含边界元素。
		tailSet(E fromElement, boolean inclusive):NavigableSet<E> 		
			 返回此 set 的部分元素视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。				
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	9、Map<K,V>接口：映射。将键映射到值的对象。Map不能包含重复的键；每个键最多可以映射到一个值。这个接口代替了Dictionary类，它是一个完全抽象的类，而不是一个接口。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		clear():void 
			从此映射中删除所有映射（可选操作）。
		compute(K key,BiFunction<? super K, ? super V, ? extends V> remappingFunction):default V 
			通过BiFunction类型的函数接口remappingFunction，计算指定key的V值得到新值。如果新值非空则则调用put(key, newValue)保存映射并返回。如果计算结果为空且key存在则调用remove(key)删除该key的映射并返回null。该函数式接口实现需在调用时由调用者实现。
		computeIfAbsent(K key,Function<? super K, ? extends V> mappingFunction):default V 
			如果key的映射值为空，则通过函数接口mappingFunction计算指定key的映射值，计算结果非空则保存映射值并返回，如果计算结果为空则返回旧的映射值。该函数式接口实现需在调用时由调用者实现。
		computeIfPresent(K key,BiFunction<? super K, ? super V, ? extends V> remappingFunction):default V 
			如果key的映射值非空，则通过函数接口mappingFunction计算指定key的映射值，计算结果非空则调用put(key, newValue)保存映射，计算结果为空则调用remove(key)删除此key映射并返回null。该函数式接口实现需在调用时由调用者实现。
		containsKey(Object key):boolean 
			如果Map包含指定键的映射，则返回true。
		containsValue(Object value):boolean 
			如果Map将一个或多个键映射到指定值，则返回true。
		entrySet():Set<Map.Entry<K, V>> 
			返回Map中包含的映射的Set视图。			
		equals(Object o):boolean 
			将指定对象与Map进行等同性比较。
		forEach(BiConsumer<? super K, ? super V> action):default void 
			对Map中的每个条目执行给定操作(执行函数式接口中的方法)，直到处理完所有条目或该操作引发异常。该函数式接口实现需在调用时由调用者实现。
		get(Object key):V 
			返回指定键被映射到的值，如果Map不包含键的映射，则返回null。
		getOrDefault(Object key, V defaultValue):default V 
			返回指定键映射到的值，或者如果Map不包含键的映射，则返回默认值defaultValue。
		hashCode():int 
			返回此Map的哈希代码值。
		isEmpty():boolean 
			如果Map为空（不包含任何key-value映射）
		keySet():Set<K> 
			返回一个包含Map所有key对象的集合。
		merge(K key, V value,BiFunction<? super V, ? super V, ? extends V> remappingFunction):default V 
			如果指定的键尚未与值相关联或与null相关联，则将其与给定的非null值相关联。（如果key对应的旧值不为空，则将给定的value与旧值传入函数接口方法进行处理得出新值，如果新值非空映射新值，如果新值为空则删除该映射）。
		put(K key, V value):V 
			将指定值与Map中指定键关联（即添加映射）。
		putAll(Map<? extends K, ? extends V> m):void 
			将指定的映射对象m中的所有key-value映射复制到此Map中。
		putIfAbsent(K key, V value):default V 
			如果指定的键尚未与值关联（或映射为null），则将其与给定值关联并返回null，否则返回旧值。
		remove(Object key):V 
			如果存在指定键的映射，则从该映射中删除该键的映射。
		remove(Object key, Object value):default boolean 
			如果指定key对应的值与value相等，则删除Map中指定的映射，并返回true，否则不删除并返回false。
		replace(K key, V value):default V 
			仅当指定键key当前映射到某个值时，才替换该条目。
		replace(K key, V oldValue, V newValue):default boolean 
			只有在当前映射到指定值(oldValue)时才替换指定键的条目(newValue)。
		replaceAll(BiFunction<? super K, ? super V, ? extends V> function):default void 
			将每个条目的值替换为在该条目上调用给定函数的结果，直到处理完所有条目或函数抛出异常。
		size():int 
			返回此映射中的键值映射的数量。
		values():Collection<V> 
			返回此Map中包含的所有V值的Collection视图。			
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	10、Map$Entry<K,V>接口：它是Map的一个内部接口。Map的entrySet()方法返回一个实现Map.Entry接口的对象集合。集合中每个对象都是底层Map中一个特定的键/值对。通过这个集合的迭代器，您可以获得每一个条目(唯一获取方式)的键或值并对值进行更改。当条目通过迭代器返回后，除非是迭代器自身的remove()方法或者迭代器返回的条目的setValue()方法，其余对源Map外部的修改都会导致此条目集变得无效，同时产生条目行为未定义。因为Map这个类没有继承Iterable接口所以不能直接通过map.iterator来遍历(list，set就是实现了这个接口，所以可以直接这样遍历),所以就只能先转化为set类型，用entrySet()方法，其中set中的每一个元素值就是map中的一个键值对，也就是Map.Entry<K,V>了，然后就可以遍历了。基本上 就是遍历map的时候才用得着它吧。
	
		接口定义：public static interface Map.Entry<K,V>
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
		comparingByKey():static <K extends Comparable<? super K>, V> Comparator<Map.Entry<K,V>> 
			静态方法，返回一个比较器，该比较器比较Map.Entry在键上的自然顺序。
		comparingByKey(Comparator<? super K> cmp):static <K, V> Comparator<Map.Entry<K, V>> 
			静态方法，返回一个比较器，该比较器使用给定的比较器按键比较Map.Entry。
		comparingByValue():static <K, V extends Comparable<? super V>> Comparator<Map.Entry<K,V>>
			静态方法，返回一个比较器，该比较器按值的自然顺序比较Map.Entry。
		comparingByValue(Comparator<? super V> cmp):static <K, V> Comparator<Map.Entry<K, V>>
			静态方法，返回一个比较器，该比较器使用给定的比较器按值比较Map.Entry。
		equals(Object o):boolean
			将指定对象与此条目进行相等性比较。
		getKey():K 
			返回与此条目对应的键。
		getValue():V 
			返回与此条目对应的值。
		hashCode():int 
			返回此映射项的哈希代码值。
		setValue(V value):V 
			用指定值替换与此条目对应的值。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	11、SortedMap<K,V>接口：它是一种提供对键进行总排序的Map。映射是根据其键的自然顺序进行排序的，或者在SortedMap创建时提供比较器（Comparator)。
			在对SortedMap的集合视图(由entrySet、keySet和values方法返回)进行迭代时，会反映这个顺序。插入到SortedMap的所有键必须实现Comparable接口（或者接受指定的比较器）。
			此外，所有这些键必须是相互可比较的（可以进行下面语句操作）：
				 k1.compareTo(k2) 	或者   comparator.compare(k1, k2)
			在SortedMap中不能抛出ClassCastException异常。如果违反此限制将导致在方法或构造函数调用时抛出令人厌恶的ClassCastException异常。
			
		父接口：Map<K,V>
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		comparator():Comparator<? super K> 
			返回用于对该映射中的键进行排序的比较器，如果该映射使用其键的自然排序，则返null。		
		firstKey():K 
			返回该映射中当前第一个（最低）键。
		headMap(K toKey):SortedMap<K,V> 
			返回此映射的键严格小于toKey的部分视图。	
		lastKey():K 
			返回此映射中当前最后一个（最高）键。
		subMap(K fromKey, K toKey):SortedMap<K,V> 
			返回此映射的键范围从包含fromKey到toKey的部分视图（不包含toKey）。
		tailMap(K fromKey):SortedMap<K,V> 
			返回此映射的键大于或等于fromKey的部分视图。	
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	12、NavigableMap<K,V>接口：NavigableMap扩展了 SortedMap，因此它也是一种基于对键进行排序的Map。并且具有了针对给定搜索目标返回最接近匹配项的导航方法。方法 lowerEntry、floorEntry、ceilingEntry
			和 higherEntry 分别返回与小于、小于等于、大于等于、大于给定键的键关联的 Map.Entry 对象，如果不存在这样的键，则返回 null。
			类似地，方法 lowerKey、floorKey、ceilingKey 和 higherKey 只返回关联的键。所有这些方法是为查找条目而不是遍历条目而设计的。
			可以按照键的升序或降序访问和遍历 NavigableMap。descendingMap 方法返回映射的一个视图，该视图表示的所有关系方法和方向方法都是逆向的。
			升序操作和视图的性能很可能比降序操作和视图的性能要好。subMap、headMap 和 tailMap 方法与名称相似的 SortedMap 方法的不同之处在于：
			可以接受用于描述是否包括（或不包括）下边界和上边界的附加参数。任何 NavigableMap 的 Submap 必须实现 NavigableMap 接口。
			此接口还定义了 firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 方法，它们返回和/或移除最小和最大的映射关系（如果存在），否则返回 null。
			subMap(K, K)、headMap(K) 和 tailMap(K) 方法被指定为返回 SortedMap，以允许现有 SortedMap 实现能相容地改进为实现 NavigableMap，但鼓励此接口的扩展和实现重写这些方法以返回 NavigableMap。类似地，可以重写 SortedMap.keySet() 以返回 NavigableSet。

		父接口：SortedMap<K,V>,Map<K,V>
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		ceilingEntry(K key):Map.Entry<K,V> 
			返回一个键-值映射关系，它与大于等于给定键的最小键关联；如果不存在这样的键，则返回 null。
		ceilingKey(K key):K 
			返回大于等于给定键的最小键；如果不存在这样的键，则返回 null。
		descendingKeySet():NavigableSet<K> 
			返回此映射中所包含键的逆序 NavigableSet 视图。
		descendingMap():NavigableMap<K,V> 
			返回此映射中所包含映射关系的逆序视图。
		firstEntry():Map.Entry<K,V> 
			返回一个与此映射中的最小键关联的键-值映射关系(Entry)；如果映射(Map)为空，则返回 null。
		floorEntry(K key):Map.Entry<K,V> 
			返回一个键-值映射关系(Entry)，它与小于等于给定键的最大键关联；如果不存在这样的键，则返回 null。
		floorKey(K key):K 
			返回小于等于给定键的最大键；如果不存在这样的键，则返回 null。
		headMap(K toKey, boolean inclusive):NavigableMap<K,V> 
			返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。
		higherEntry(K key):Map.Entry<K,V> 
			返回一个键-值映射关系，它与严格大于给定键的最小键关联；如果不存在这样的键，则返回 null。	
		higherKey(K key):K 
			返回严格大于给定键的最小键；如果不存在这样的键，则返回 null。
		lastEntry():Map.Entry<K,V> 
			返回与此映射中的最大键关联的键-值映射关系；如果映射为空，则返回 null。
		lowerEntry(K key):Map.Entry<K,V> 
			 返回一个键-值映射关系，它与严格小于给定键的最大键关联；如果不存在这样的键，则返回 null。
		lowerKey(K key):K 
			返回严格小于给定键的最大键；如果不存在这样的键，则返回 null。
		navigableKeySet():NavigableSet<K> 
			返回此映射中所包含键的 NavigableSet 视图。
		pollFirstEntry():Map.Entry<K,V> 
			 移除并返回与此映射中的最小键关联的键-值映射关系(Entry)；如果映射为空，则返回 null。
		pollLastEntry():Map.Entry<K,V> 
			移除并返回与此映射中的最大键关联的键-值映射关系；如果映射为空，则返回 null。
		subMap(K fromKey, boolean fromInclusive,K toKey, boolean toInclusive):NavigableMap<K,V> 
			 返回此映射的部分视图，其键的范围从 fromKey 到 toKey。（注意：fromInclusive表示是否包含fromKey这个边界；toInclusive表示是否包含toKey这个边界）
		tailMap(K fromKey, boolean inclusive):NavigableMap<K,V> 
			返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。				
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	13、Iterator<E>接口：迭代器。用来迭代collection容器中元素的迭代器。	
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
		forEachRemaining(Consumer<? super E> action):default void 
			对剩余的每个元素执行给定的操作，直到所有元素都被处理或操作引发异常为止。
		hasNext():boolean 
			如果迭代器包含更多元素，则返回true。
		next():E 
			返回迭代器中的下一个元素。
		remove():default void 
			从集合中移除此迭代器返回的最后一个元素（即将迭代器最新返回的元素删除并继续迭代）。使用迭代器 的 remove() 方法后，迭代器删除了当前读取的元素 “b”，并且继续往下遍历元素，达到了在删除元素时不破坏遍历的目的。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	14、ListIterator<E>接口：列表迭代器。它允许程序员沿任一方向遍历列表，在迭代期间修改列表，并获取迭代器在列表中的当前位置。ListIterator没有当前元素；
			其光标位置始终位于调用previous（）将返回的元素和将返回的元素之间。
					
		父接口：Iterator<E>
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
		add(E e):void 
			将指定的元素插入列表。
		hasPrevious():boolean 
			如果列表迭代器在反向遍历列表时包含更多元素，则返回true。
		nextIndex():int 
			返回列表中ListIterator所在位置后面元素的索引
		previous():E 
			返回列表中的前一个元素，并向后移动光标位置。
		previousIndex():int 
			返回列表中ListIterator所在位置的前一个元素索引，该索引将由对Previous（）的后续调用返回。
		set(E e):void 
			将next（）或previous（）返回的最后一个元素替换为指定的元素。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	15、Spliterator<T>接口：可分割迭代器。不同以往的iterator需要顺序迭代，Spliterator可以分割为若干个小的迭代器进行并行操作，
			既可以实现多线程操作提高效率，又可以避免普通迭代器的fail-fast机制所带来的异常。Spliterator可以配合1.8新加的Stream进行并行流的实现，大大提高处理效率。。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	属性：通过characteristics（）方法返回的值，用来标识实现类所具有的的特征
		public static final int ORDERED    = 0x00000010;//表示元素是有序的（每一次遍历结果相同）
		public static final int DISTINCT   = 0x00000001;//表示元素不重复
		public static final int SORTED     = 0x00000004;//表示元素是按一定规律进行排列（有指定比较器）
		public static final int SIZED      = 0x00000040;//是否确定大小
		public static final int NONNULL    = 0x00000100;//表示迭代器中没有null元素
		public static final int IMMUTABLE  = 0x00000400;//表示元素不可变
		public static final int CONCURRENT = 0x00001000;//表示迭代器可以多线程操作
		public static final int SUBSIZED   = 0x00004000;//表示子Spliterators都具有SIZED特性
	方法：
		characteristics():int 
			返回Spliterator对象的一组特征值(指的是上面的属性值)。一般实现类中的属性就是几个属性进行或（||）操作之后的结果。
		estimateSize():long 
			返回一个预估的值，等于执行forEachRemaining方法时调用tryAdvance的次数。	如果这个值过大，或者需要太复杂的计算过程，那么直接回返回long型的最大值
		forEachRemaining(Consumer<? super T> action):default void 
			对Spliterator的每一个对象执行tryAdvance操作
		getComparator():default Comparator<? super T> 
			如果Spliterator的具体实现具有SORTED属性，那么此方法会返回一个相应的比较器，否则会返回null
		getExactSizeIfKnown():default long 
			返回Spliterator对象确切的大小，如果存在SIZED属性，则返回estimateSize()方法的返回值，否则返回-1
		hasCharacteristics(int characteristics):default boolean 
			根据characteristics()与参数相与的结果看Spliterator对象是否包含参数指定的属性
		tryAdvance(Consumer<? super T> action):boolean 
			如果有剩余的元素存在，执行参数给定的操作，并返回true，否则就返回false。 如果Spliterator对象具有ORDERED属性，那么tryAdvance也会按照相应的顺序去执行。
		trySplit():Spliterator<T> 
			如果这个Spliterator是可以被分割的，那么这个方法会返回一个Spliterator，与原来的Spliterator平分其中的元素，如果原Spliterator的元素个数单数，
			两个Spliterator的元素个数相差1，基本是相同的。如果Spliterator不能再分割，那么会返回null	
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	16、OfPrimitive<T, T_CONS, T_SPLITR extends Spliterator.OfPrimitive<T, T_CONS, T_SPLITR>>接口：
			它是Spliterator<T>接口的一个内部接口，并且扩展于Spliterator<T>接口。与Spliterator几乎无差别，只是将trySplit，tryAdvance，forEachRemaining三个方法中的参数类型做了一点小小的变化，更加适合基本参数类型。
		泛型参数说明：
			
		父接口：Spliterator<T>
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		forEachRemaining(T_CONS action):default void 
			对剩余的每个元素执行给定的操作，在当前线程中按顺序执行，直到处理完所有元素或操作引发异常为止。
		tryAdvance(T_CONS action):boolean 
			如果存在剩余的元素，则对其执行给定的操作，返回true；否则返回false。
		trySplit():T_SPLITR 
			如果可以对该spliterator进行分区，则返回一个包含元素的spliterator，从该方法返回时，不覆盖原spliterator 。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
	17、Spliterator$OfDouble接口：它是Spliterator<T>接口的一个内部接口，扩展于OfPrimitive<Double, DoubleConsumer, OfDouble>。
			专门用于Double类型的的Spliterator。
	
		父接口：Spliterator.OfPrimitive<Double,DoubleConsumer,Spliterator.OfDouble>,Spliterator<Double>		
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		forEachRemaining(Consumer<? super Double> action):default void 
			对剩余的每个元素执行给定的操作，在当前线程中按顺序执行，直到处理完所有元素或操作引发异常为止。
		forEachRemaining(DoubleConsumer action):default void 
			对剩余的每个元素执行给定的操作，在当前线程中按顺序执行，直到处理完所有元素或操作引发异常为止。
		tryAdvance(Consumer<? super Double> action):default boolean 
			如果存在剩余的元素，则对其执行给定的操作，返回true；否则返回false。
		tryAdvance(DoubleConsumer action):boolean 
			如果存在剩余的元素，则对其执行给定的操作，返回true；否则返回false。
		trySplit():OfDouble
			如果可以对该spliterator进行分区，则返回一个包含元素的spliterator，从该方法返回时，不覆盖原spliterator 。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	18、Spliterator$OfInt接口：它是Spliterator<T>接口的一个内部接口，扩展于OfPrimitive<Integer, IntConsumer, OfInt>。
			专门用于int值的Spliterator。
	
		父接口：Spliterator.OfPrimitive<Integer,IntConsumer,Spliterator.OfInt>,Spliterator<Integer>	
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		forEachRemaining(Consumer<? super Integer> action):default void 
			对剩余的每个元素执行给定的操作，在当前线程中按顺序执行，直到处理完所有元素或操作引发异常为止。
		forEachRemaining(IntConsumer action):default void 
			对剩余的每个元素执行给定的操作，在当前线程中按顺序执行，直到处理完所有元素或操作引发异常为止。
		tryAdvance(Consumer<? super Integer> action):default boolean 
			如果存在剩余的元素，则对其执行给定的操作，返回true；否则返回false。
		tryAdvance(IntConsumer action):boolean 
			如果存在剩余的元素，则对其执行给定的操作，返回true；否则返回false。
		trySplit():OfInt 
			如果可以对该spliterator进行分区，则返回一个包含元素的spliterator，从该方法返回时，不覆盖原spliterator 。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	19、Spliterator$OfLong接口：它是Spliterator<T>接口的一个内部接口，扩展于PrimitiveIterator<Long,LongConsumer>
			专门用于Long值的Spliterator。
		
		父接口：Spliterator.OfPrimitive<Long,LongConsumer,Spliterator.OfLong>,Spliterator<Long>
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
		forEachRemaining(Consumer<? super Long> action):default void 
			对剩余的每个元素执行给定的操作，在当前线程中按顺序执行，直到处理完所有元素或操作引发异常为止。
		forEachRemaining(LongConsumer action):default void 
			对剩余的每个元素执行给定的操作，在当前线程中按顺序执行，直到处理完所有元素或操作引发异常为止。
		tryAdvance(Consumer<? super Long> action):default boolean 
			如果存在剩余的元素，则对其执行给定的操作，返回true；否则返回false。
		tryAdvance(LongConsumer action):boolean 
			如果存在剩余的元素，则对其执行给定的操作，返回true；否则返回false。
		trySplit():OfLong 
			如果可以对该spliterator进行分区，则返回一个包含元素的spliterator，从该方法返回时，不覆盖原spliterator 。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	20、PrimitiveIterator<T, T_CONS>接口：原始迭代器。为int、long和double值提供了专门的子类型。			
		
		父接口：Iterator<T>	
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
		forEachRemaining(T_CONS action):void 
			对剩余的每个元素执行给定的操作，按元素在迭代时发生的顺序执行，直到所有元素都被处理或操作引发异常为止。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	21、PrimitiveIterator$OfDouble接口：专门针对Double类型的迭代器
		
		父接口：PrimitiveIterator<Double,DoubleConsumer>,Iterator<Double>		
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
		forEachRemaining(Consumer<? super Double> action):default void 
			对剩余的每个元素执行给定的操作，直到所有元素都被处理或操作引发异常为止。
		forEachRemaining(DoubleConsumer action):default void 
			对剩余的每个元素执行给定的操作，直到所有元素都被处理或操作引发异常为止。
		next():default Double 
			返回迭代中的下一个元素。
		nextDouble():double 
			返回迭代中的下一个double元素。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	22、PrimitiveIterator$OfInt接口：专门针对int类型的迭代器
		
		父接口：PrimitiveIterator<Integer,IntConsumer>,Iterator<Integer>		
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
		forEachRemaining(Consumer<? super Integer> action):default void 
			对剩余的每个元素执行给定的操作，直到所有元素都被处理或操作引发异常为止。
		forEachRemaining(IntConsumer action):default void 
			对剩余的每个元素执行给定的操作，直到所有元素都被处理或操作引发异常为止。
		next():default Integer 
			返回迭代中的下一个元素。
		nextDouble():int
			返回迭代中的下一个int元素。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	23、PrimitiveIterator$OfLong接口：专门针对long类型的迭代器
		
		父接口：PrimitiveIterator<Long,LongConsumer>,Iterator<Long>	
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
		forEachRemaining(Consumer<? super Long> action):default void 
			对剩余的每个元素执行给定的操作，直到所有元素都被处理或操作引发异常为止。
		forEachRemaining(LongConsumer action):default void 
			对剩余的每个元素执行给定的操作，直到所有元素都被处理或操作引发异常为止。
		next():default Long 
			返回迭代中的下一个元素。
		nextDouble():long
			返回迭代中的下一个long元素。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	24、Enumeration<E>接口：枚举接口。实现枚举接口的对象生成一系列元素，一次一个。对NextElement方法的连续调用返回序列的连续元素。目前已被迭代器Iterator<E>淘汰
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
		hasMoreElements():boolean 
			测试此枚举是否包含更多元素。
		nextElement():E 
			如果此枚举对象至少还要提供一个元素，则返回此枚举的下一个元素。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	25、Formattable接口：可格式化接口。任何需要使用Formatter的“s”转换说明符执行自定义格式化的类都必须实现Formattable接口。这个接口允许对任意对象进行格式化的基本控制。
	
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
		formatTo(Formatter formatter, int flags, int width, int precision):void 
			使用提供的formatter格式化对象。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	26、Comparable<T>接口：可比较接口。这个接口对实现它的每个类的对象施加了一个总的顺序。这种排序称为类的自然排序，类的CompareTo方法称为类的自然比较方法。
			实现此接口的对象列表（和数组）可以按collections.sort（和array.sort）自动排序。实现此接口的对象可以用作sorted map中的键或sorted set中的元素，而无需指定比较器。
	
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
		compareTo(T o):int 
			将此对象与指定的顺序对象进行比较。返回负整数、零或正整数，因为当前对象小于、等于或大于指定对象。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	
	27、Comparator<T>接口：比较器，用于排序、分组。比较器可以传递给排序方法，（例如collections.sort或array.sort）允许对排序顺序进行精确控制。比较器还可用于控制某些数据结构（如sorted sets或sorted maps）的顺序。或者为没有自然排序的对象集合提供排序。
	
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
		comparing(Function<? super T, ? extends U> keyExtractor):static <T, U extends Comparable<? super U>> Comparator<T> 
			接受一个函数，该函数从类型T中提取一个可比较的排序键，并返回一个通过该排序键进行比较的比较器。
		comparing(Function<? super T, ? extends U> keyExtractor,Comparator<? super U> keyComparator):static <T, U> Comparator<T>
			接受从类型T中提取排序键的函数，并返回使用指定的比较器与该排序键进行比较的比较器。 
		comparingDouble(ToDoubleFunction<? super T> keyExtractor):static<T> Comparator<T> 
			接受一个函数，该函数从类型T中提取一个Double排序键，并返回一个比较器，该比较器通过该排序键进行比较。
		comparingInt(ToIntFunction<? super T> keyExtractor):static <T> Comparator<T> 
			接受一个函数，该函数从类型T中提取int排序键，并返回一个比较器，该比较器通过该排序键进行比较。
		comparingLong(ToLongFunction<? super T> keyExtractor):static <T> Comparator<T> 
			接受一个函数，该函数从类型T中提取一个long排序键，并返回一个比较器，该比较器通过该排序键进行比较。
		naturalOrder():static <T extends Comparable<? super T>> Comparator<T> 
			返回按自然顺序比较Comparable对象的比较器。
		nullsFirst(Comparator<? super T> comparator):static <T> Comparator<T> 
			返回一个null-friendly(空友好)比较器，该比较器将空（null）视为小于非空(non-null)。
		nullsLast(Comparator<? super T> comparator):static <T> Comparator<T> 
			返回一个null-friendly(空友好)比较器，该比较器认为空（null）大于非空（non-null）。
		reverseOrder():static <T extends Comparable<? super T>> Comparator<T> 
			返回一个与自然顺序相反的比较器。
		compare(T o1, T o2):int 
			比较其顺序的两个参数。
		equals(Object obj):boolean 
			指定的对象是否“等于”此比较器。
		reversed():default Comparator<T> 
			返回一个比较器，强制执行此比较器的反向顺序。
		thenComparing(Comparator<? super T> other):default Comparator<T> 
			用指定的比较器返回一个lexicographic-order比较器。
		thenComparing(Function<? super T, ? extends U> keyExtractor):default <U extends Comparable<? super U>> Comparator<T> 
			返回具有提取可比较排序键的函数的lexicographic-order比较器。
		thenComparing(Function<? super T, ? extends U> keyExtractor,Comparator<? super U> keyComparator):default <U> Comparator<T> 
			返回一个lexicographic-order比较器，该比较器具有提取要与给定比较器进行比较的键的函数。
		thenComparingDouble(ToDoubleFunction<? super T> keyExtractor):default Comparator<T> 
			返回具有提取Double排序键的函数的lexicographic-order单词顺序比较器。
		thenComparingInt(ToIntFunction<? super T> keyExtractor):default Comparator<T>
			返回具有提取int排序键的函数的lexicographic-order单词顺序比较器。
		thenComparingLong(ToLongFunction<? super T> keyExtractor):default Comparator<T> 
			返回具有提取Long排序键的函数的lexicographic-order单词顺序比较器。			
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------	
	28、RandomAccess接口：随机访问接口。列表实现类使用的标记接口，用于指示它们支持快速（通常是恒定时间）随机访问。此接口的主要目的是允许通用算法在应用于随机或顺序访问列表时更改其行为以提供良好的性能。
		
		实现类：ArrayList, AttributeList, CopyOnWriteArrayList, RoleList, RoleUnresolvedList, Stack, Vector
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	29、Observer接口：观察对象接口。当一个类希望被通知可观察对象的变化时，它可以实现Observer接口。
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
		update(Observable o, Object arg):void 
			只要更改Observed对象，此方法就会被调用。	
	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
	30、EventListener：事件监听器。是一个标记接口，就是说该接口内是没有任何方法的。所有事件监听器都需要实现该接口。事件监听器注册在事件源上，当事件源的属性或状态改变的时候，调用相应监听器内的回调方法。

	-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		