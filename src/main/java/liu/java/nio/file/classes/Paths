----------------------------------------Paths--------------------------------------------------------------------------------------------------------------
Paths：路径工厂		【Since:1.7】
	此类只包含通过转换路径字符串或URI返回路径的静态方法。
	
	类定义	：public final class Paths
------------------------------------------------------------------------------------------------------------------------------------------------------
Method Summary（方法概要）：
	get(String first, String... more):static Path 
		first - 路径字符串或路径字符串的初始部分。
		more - 要联接以形成路径字符串的其他字符串。
		将路径字符串或连接后形成路径字符串的字符串序列转换为Path。如果more未指定任何元素，则第一个参数的值是要转换的路径字符串。如果more指定了一个或多个元素，则每个非空字符串（包括第一个）都被视为name元素序列（请参见Path），并被联接以形成路径字符串。有关如何联接字符串的详细信息是特定于提供器的，但通常使用名称分隔符作为分隔符来联接字符串。例如，如果名称分隔符为“/”，并且调用了getPath（“/foo”、“bar”、“gus”），则路径字符串“/foo/bar/gus”将转换为路径。如果第一个是空字符串，而more不包含任何非空字符串，则返回表示空路径的Path。
		该路径是通过调用默认文件系统的getPath方法获得的。
		注意，虽然这个方法非常方便，但是使用它意味着假定引用了默认的文件系统（FileSystem），并限制了调用代码的实用性。因此，它不应该在用于灵活重用的库代码中使用。更灵活的选择是使用现有Path实例作为锚，例如：
		     Path dir = ...
     		 Path path = dir.resolve("file");
     	返回结果结果路径。
     	【Throws】：
			InvalidPathException 如果无法将路径字符串转换为Path。
	get(URI uri):static Path 
		uri - 要转换的URI。
		将给定的URI转换为Path对象。
		此方法迭代已安装的提供器，以查找由给定URI的URI方案（scheme）标识的提供器。比较URI方案（scheme）时不考虑大小写。如果找到提供器，则调用其getPath方法来转换URI。
		对于由URI方案（scheme）“file”标识的默认提供器，给定的URI有一个非空路径组件，以及未定义的查询（query）和片段（fragment）组件。权限（authority）组件是否可能存在是平台特定的。返回的路径（Path）与默认文件系统关联。
		默认提供器为File类提供类似的往返保证。对于给定路径p，保证
			Paths.get(p.toUri()).equals( p.toAbsolutePath());
		只要原始路径(Path)、URI和新路径都在同一Java虚拟机中创建（可能是不同的调用）。其他供应商是否作出任何担保是特定于供应商的，因此未指明。
		返回结果结果路径。
		【Throws】：
			IllegalArgumentException 如果uri参数的前提条件不成立。URI的格式是特定于提供器的。
			FileSystemNotFoundException 由URI标识的文件系统不存在，无法自动创建，或者未安装由URI的方案（scheme）组件标识的提供器。
			SecurityException 如果安装了安全管理器并且拒绝未指定的访问文件系统的权限。
		
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
附录：
	1、注：文档中的△符号表示覆盖重写方法，✘符号表示已淘汰的方法。	
	2、注：文档中的★符号表示抽象方法或者直接抛出UnsupportedOperationException异常的方法，总之没有实现具体功能代码的方法。	
	3、java8中nio直接缓冲区与非直接缓冲区的区别：
		非直接缓冲区：通过allocate方法分配缓冲区，将缓冲区建立在JVM的内存中。
		直接缓冲区：通过allocateDirect方法分配直接缓冲区，将缓冲区建立在物理内存中，可以提供更高效率。
		
		
		
		
		
		
		
		
		