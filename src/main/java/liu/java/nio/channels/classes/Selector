----------------------------------------Selector--------------------------------------------------------------------------------------------------------------
Selector：选择器 【Since:1.4】
	SelectableChannel对象的多路复用器。
	可以通过调用此类的open方法来创建选择器，该方法将使用系统的默认选择器提供程序来创建新的选择器。也可以通过调用自定义选择器提供程序的openSelector方法来创建选择器。选择器保持打开状态，直到通过其close方法关闭。
	可选通道的选择器注册由SelectionKey对象表示。选择器维护三组选择键：
		● 键集包含表示此选择器当前通道注册的键。这个集合由keys方法返回。
		● 所选键集是一组键，以便在之前的选择操作期间检测到每个键的通道已准备就绪，可以进行键的关注集中标识的至少一个操作。此集合由selectedKeys方法返回。选定的键集始终是键集的子集。
		● 已取消的键集是已取消但其通道尚未取消注册的键集。无法直接访问此集合。取消的键集始终是键集的子集。
	在新创建的选择器中，这三个集合都是空的。
	键被添加到选择器的键集，作为通过通道的注册方法注册通道的副作用。在选择操作期间，取消的键将从键集中删除。键集本身不可直接修改。
	当一个键被取消时，它会被添加到它的选择器的取消键集中，无论是通过关闭它的通道还是通过调用它的取消方法。取消某个键将导致在下一个选择操作期间取消其通道的注册，此时该键将从选择器的所有键集中删除。
	键通过选择操作添加到所选键集。通过调用集合的remove方法或调用从集合中获取的迭代器的remove方法，可以直接从选定的键集中删除键。键永远不会以任何其他方式从所选键集中删除；它们尤其不会作为选择操作的副作用删除。键不能直接添加到选定的键集。
	
	Selection：
	在每次selection操作期间，可以将键添加到选择器的选定键集中，也可以从选择器的键集中删除键，也可以从选择器的键集中删除键。选择由select()、select(long)和selectNow()方法执行，包括三个步骤：
		1、已取消的键集中的每个键都将从其所属的每个键集中删除，并且其通道将被取消注册。此步骤将取消的键设置为空。
		2、在selection操作开始时，将询问底层操作系统是否有关于每个剩余通道是否准备好执行由其键的关注集标识的任何操作的更新。对于准备好进行至少一个此类操作的通道，将执行以下两个操作之一：
			● 如果通道的键还未在选定的键集中，则会将其添加到该集合中，并修改其就绪操作集，以准确标识通道现在报告为就绪的那些操作。先前记录在就绪集中的任何就绪信息都将被丢弃。
			● 否则，通道的键已经在选定的键集中，因此它的就绪操作集将被修改，以标识报告通道已就绪的任何新操作。以前记录在就绪集中的任何就绪信息都将被保留；换句话说，底层系统返回的就绪集将按位分离到键的当前就绪集中。
		       如果此步骤开始时键集中的所有键都有空的关注集，则所选键集和任何键的就绪操作集都不会更新。
		3、如果在执行步骤（2）的过程中向已取消的键集添加了任何键，则它们将按步骤（1）进行处理。
	selection操作是否阻塞等待一个或多个通道准备就绪，如果是，等待多长时间，这是三种选择方法之间唯一的本质区别。
	
	Concurrency（并发性）：
	选择器本身对于多个并发线程的使用是安全的；但是，它们的键集却不安全。
	selection操作在选择器本身、键集和所选键集上按该顺序同步。在上述步骤（1）和（3）中，它们还同步取消的键集。
	在进行selection操作时对选择器键的关注集所做的更改对该操作没有影响；下一个selection操作将看到这些更改。
	可以随时取消按键和关闭通道。因此，在一个或多个选择器的键集中存在一个键并不意味着该键是有效的或其通道是打开的。如果另一个线程可能会取消某个键或关闭某个通道，那么应用程序代码应该小心地同步和检查这些条件。
	在select()或select(long)方法之一中阻塞的线程可能会被其他线程以三种方式之一中断：
		● 通过调用选择器的wakeup方法，
		● 通过调用选择器的close方法，或
		● 通过调用被阻塞线程的interrupt方法，在这种情况下，将设置其中断状态，并调用选择器的wakeup方法。
	close方法在选择器和所有三个键集上同步的顺序与selection操作中的顺序相同。
	通常，选择器的键和选定的键集对于多个并发线程的使用不安全。如果这样的线程可以直接修改其中一个集，那么应该通过在该集上同步来控制访问。这些集合的迭代器方法返回的迭代器快速失败（fail-fast）：如果在创建迭代器之后以任何方式修改了集合，除了调用迭代器自己的remove方法，那么将引发ConcurrentModificationException异常。
	
	
	
	类定义	：public abstract class Selector implements Closeable
	实现接口	：AutoCloseable, Closeable
	直接子类	：AbstractSelector
------------------------------------------------------------------------------------------------------------------------------------------------------
Constructor Summary（构造器概要）：
	protected Selector()
		初始化此类的新实例。
Method Summary（方法概要）：
	open():static Selector 
		打开选择器。
		新的选择器是通过调用系统范围的默认SelectorProvider对象的openSelector方法创建的。
		返回一个新的选择器。
		【Throws】：
			IOException 如果发生I/O错误。
	close():abstract void 
		★ △ 关闭此选择器。
		如果某个线程当前被此选择器的某个selection方法阻塞，则该线程将被中断，就像调用选择器的wakeup方法一样。
		仍然与此选择器关联的任何未取消的键都将失效，它们的通道将被取消注册，并且与此选择器关联的任何其他资源将被释放。
		如果此选择器已关闭，则调用此方法无效。
		关闭选择器后，除调用此方法或wakeup方法外，任何进一步尝试使用它都将导致引发ClosedSelectorException异常。
		【Throws】：
			IOException 如果发生I/O错误。
	isOpen():abstract boolean 
		★ 指示此选择器是否打开。
		如果且仅当此选择器打开时返回true。
	keys():abstract Set<SelectionKey> 
		★ 返回此选择器的键集。
		键集不能直接修改。只有在键被取消并且其通道被取消注册后，才会删除该键。任何修改键集的尝试都将导致引发UnsupportedOperationException异常。
		键集不是线程安全的。
	provider():abstract SelectorProvider 
		★ 返回创建此通道的提供程序。
	select():abstract int 
		★ 选择一组键，其对应通道已准备好进行I/O操作。
		此方法执行阻塞selection操作。它仅在至少选择一个通道、调用选择器的wakeup方法或中断当前线程（以先到者为准）后返回。
		返回已更新其就绪操作集的键数量，可能为零。
		【Throws】：
			IOException 如果发生I/O错误。
			ClosedSelectorException 如果此选择器关闭。
	select(long timeout):abstract int 
		timeout - 如果为正数，则在等待通道准备就绪时阻塞最长超时毫秒（或多或少）；如果为零，则无限期阻塞；不得为负数。
		★ 选择一组键，其对应通道已准备好进行I/O操作。
		此方法执行阻塞selection操作。只有在选择了至少一个通道、调用了选择器的wakeup方法、中断了当前线程或给定的超时时间到期（以先到者为准）后，才会返回。
		此方法不提供实时保证：它通过调用Object.wait(long)方法来调度超时。
		返回已更新其就绪操作集的键数量，可能为零。
		【Throws】：
			IOException 如果发生I/O错误。
			ClosedSelectorException 如果此选择器关闭。
			IllegalArgumentException 如果timeout参数的值为负。
	selectedKeys():abstract Set<SelectionKey> 
		★ 返回此选择器的选定键集。
		键可以从选定的键集中删除，但不能直接添加到选定的键集中。任何向键集添加对象的尝试都将导致引发UnsupportedOperationException异常。
		选定的键集不是线程安全的。
		【Throws】：
			ClosedSelectorException 如果此选择器关闭。
	selectNow():abstract int 
		★ 选择一组键，其对应通道已准备好进行I/O操作。
		此方法执行非阻塞selection操作。如果自上一个selection操作以来没有通道可选择，则此方法立即返回零。
		调用此方法将清除wakeup方法的任何先前调用的效果。
		返回已通过选择操作更新其就绪操作集的键数量，可能为零。
		【Throws】：
			IOException 如果发生I/O错误。
			ClosedSelectorException 如果此选择器关闭。
	wakeup():abstract Selector 
		★ 使尚未返回的第一个selection操作立即返回。
		如果另一个线程当前在select()或select(long)方法的调用中被阻塞，那么该调用将立即返回。如果当前没有正在进行的selection操作，则除非同时调用selectNow()方法，否则这些方法之一的下一次调用将立即返回。在任何情况下，该调用返回的值都可能是非零的。除非在此期间再次调用此方法，否则对select()或select(long)方法的后续调用将像往常一样阻塞。
		在两个连续的selection操作之间多次调用此方法与只调用一次具有相同的效果。
		返回此选择器。
	
	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
附录：
	1、注：文档中的△符号表示覆盖重写方法，✘符号表示已淘汰的方法。	
	2、注：文档中的★符号表示抽象方法或者直接抛出UnsupportedOperationException异常的方法，总之没有实现具体功能代码的方法。	
	3、java8中nio直接缓冲区与非直接缓冲区的区别：
		非直接缓冲区：通过allocate方法分配缓冲区，将缓冲区建立在JVM的内存中。
		直接缓冲区：通过allocateDirect方法分配直接缓冲区，将缓冲区建立在物理内存中，可以提供更高效率。