----------------------------------------ByteOrder--------------------------------------------------------------------------------------------------------------
ByteOrder：字节顺序	【Since:JDK1.4】
	字节顺序的类型安全枚举。		
		
		
	
	类定义	：public final class ByteOrder
------------------------------------------------------------------------------------------------------------------------------------------------------
Field Summary（字段概要）：
	BIG_ENDIAN : ByteOrder
		表示big-endian字节顺序的常量。按照这个顺序，多字节值的字节从最高有效到最低有效。
	LITTLE_ENDIAN : ByteOrder
		表示 little-endian字节顺序的常量。按照这个顺序，多字节值的字节从最低有效到最高有效。


Method Summary（方法概要）：
	nativeOrder():static ByteOrder 
		检索底层平台的本机字节顺序。
		此方法被定义为使性能敏感的Java代码可以分配与硬件相同字节顺序的直接缓冲区。当使用此类缓冲区时，本机代码库通常效率更高。
		返回这个Java虚拟机运行的硬件的本地字节顺序。
	toString():String 
		构造描述此对象的字符串。
		此方法返回字符串"BIG_ENDIAN"和"LITTLE_ENDIAN"。
	
	
	
	

		
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
附录：
	1、注：文档中的△符号表示覆盖重写方法，✘符号表示已淘汰的方法。	
	2、注：文档中的★符号表示抽象方法或者直接抛出UnsupportedOperationException异常的方法，总之没有实现具体功能代码的方法。	
	3、java8中nio直接缓冲区与非直接缓冲区的区别：
		非直接缓冲区：通过allocate方法分配缓冲区，将缓冲区建立在JVM的内存中。
		直接缓冲区：通过allocateDirect方法分配直接缓冲区，将缓冲区建立在物理内存中，可以提供更高效率。
		
	4、BIG_ENDIAN 与 LITTLE_ENDIAN
		BIG_ENDIAN是指低地址存放最高有效字节（MSB），	而LITTLE_ENDIAN则是低地址存放最低有效字节（LSB）。 谈到字节序的问题，必然牵涉到两大CPU派系。那就是Motorola的PowerPC系列CPU和Intel的x86系列CPU。PowerPC系列采用BIG_ENDIAN方式存储数据，而x86系列则采用LITTLE_ENDIAN方式存储数据。











		