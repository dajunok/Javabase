----------------------------------------MappedByteBuffer--------------------------------------------------------------------------------------------------------------
MappedByteBuffer：文件映射	【Since:JDK1.4】
	一种直接字节缓冲区，其内容是文件的内存映射区域。
	映射的字节缓冲区是通过FileChannel.map方法创建的。此类使用特定于内存映射文件区域的操作扩展了ByteBuffer类。
	映射的字节缓冲区及其表示的文件映射在缓冲区本身被垃圾收集之前保持有效。
	映射字节缓冲区的内容可以随时更改，例如，如果此程序或其他程序更改了映射文件的相应区域的内容。这些更改是否发生以及发生时，取决于操作系统，因此未指明。	
	映射字节缓冲区的全部或部分在任何时候都可能变得不可访问，例如，如果映射文件被截断。尝试访问映射字节缓冲区的不可访问区域不会更改缓冲区的内容，并且会导致在访问时或稍后某个时间引发未指定的异常。因此，强烈建议采取适当的预防措施，以避免此程序或同时运行的程序操作映射文件，但读取或写入文件内容的情况除外。
	映射的字节缓冲区的行为与普通的直接字节缓冲区没有区别。
	
	类定义	：public abstract class MappedByteBuffer  extends ByteBuffer
	实现接口	：Comparable<ByteBuffer>
------------------------------------------------------------------------------------------------------------------------------------------------------
Method Summary（方法概要）：
	force():final MappedByteBuffer 
		强制将对此缓冲区内容所做的任何更改写入包含映射文件的存储设备。
		如果映射到此缓冲区的文件驻留在本地存储设备上，那么当此方法返回时，将确保自创建缓冲区或上次调用此方法以来对其所做的所有更改都已写入该设备。
		如果文件不在本地设备上，则不提供此类保证。
		如果此缓冲区未在读/写模式（FileChannel.MapMode.READ_WRITE）下映射，则调用此方法没有任何效果。
		返回此缓冲器。
	isLoaded():final boolean 
		指示此缓冲区的内容是否驻留在物理内存中。
		返回值为true意味着很可能此缓冲区中的所有数据都驻留在物理内存中，因此可以在不发生任何虚拟内存页错误或I/O操作的情况下访问这些数据。返回值false并不一定意味着缓冲区的内容不驻留在物理内存中。
		返回的值是一个提示，而不是一个保证，因为在调用此方法返回时，底层操作系统可能已经调出了缓冲区的一些数据。
		如果此缓冲区的内容可能驻留在物理内存中，则返回true。
	load():final MappedByteBuffer 
		将此缓冲区的内容加载到物理内存中。
		这个方法尽最大努力确保当它返回时，这个缓冲区的内容驻留在物理内存中。调用此方法可能会导致一些页面错误和I/O操作发生。
		返回此缓冲器。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
		
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------		
附录：
	1、注：文档中的△符号表示覆盖重写方法，✘符号表示已淘汰的方法。	
	2、注：文档中的★符号表示抽象方法或者直接抛出UnsupportedOperationException异常的方法，总之没有实现具体功能代码的方法。	
	3、java8中nio直接缓冲区与非直接缓冲区的区别：
		非直接缓冲区：通过allocate方法分配缓冲区，将缓冲区建立在JVM的内存中。
		直接缓冲区：通过allocateDirect方法分配直接缓冲区，将缓冲区建立在物理内存中，可以提供更高效率。		
	4、BIG_ENDIAN 与 LITTLE_ENDIAN
		BIG_ENDIAN是指低地址存放最高有效字节（MSB），	而LITTLE_ENDIAN则是低地址存放最低有效字节（LSB）。 谈到字节序的问题，必然牵涉到两大CPU派系。那就是Motorola的PowerPC系列CPU和Intel的x86系列CPU。PowerPC系列采用BIG_ENDIAN方式存储数据，而x86系列则采用LITTLE_ENDIAN方式存储数据。











		